<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en-US"> <![endif]-->
<!--[if IE 7]> <html class="no-js ie7 oldie" lang="en-US"> <![endif]-->
<!--[if IE 8]> <html class="no-js ie8 oldie" lang="en-US"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="js" lang="en-US"><!--<![endif]--><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><script src="the-c-is-efficient-language-fallacy_files/widgets.js" type="text/javascript"></script><script src="the-c-is-efficient-language-fallacy_files/client.js" async="" type="text/javascript" id="LR1"></script><script async="" src="the-c-is-efficient-language-fallacy_files/cbgapi.loaded_1"></script><script async="" src="the-c-is-efficient-language-fallacy_files/cbgapi.loaded_0"></script><script src="the-c-is-efficient-language-fallacy_files/auth016.js" type="text/javascript"></script><script gapi_processed="true" src="the-c-is-efficient-language-fallacy_files/plusone.js" type="text/javascript"></script><script src="the-c-is-efficient-language-fallacy_files/widgets.js" type="text/javascript"></script><link id="galleria-theme" href="the-c-is-efficient-language-fallacy_files/galleria.css" rel="stylesheet"><link media="all" href="the-c-is-efficient-language-fallacy_files/widget118.css" type="text/css" rel="stylesheet">
	<meta charset="UTF-8">
	<title>The “C is Efficient” Language Fallacy – Good Math, Bad Math</title>
		<!--[if IE]><![endif]-->
		<meta property="fb:admins" content="10200068">
			<meta property="og:title" content="The “C is Efficient” Language Fallacy">
		<meta property="og:type" content="article">
				<meta property="og:image" content="">
		<meta property="og:url" content="http://scienceblogs.com/goodmath/2006/11/02/the-c-is-efficient-language-fa/">
		<meta property="og:description" content="I came across an article yesterday about programming languages, which hit on one of my major peeves, so I can’t resist responding. The article is at greythumb.org, and it’s called [Programmer's rant: what should and should not be added to C/C++](http://www.greythumb.org/blog/index.php?/archives/152-Programmers-rant-what-should-and-should-not-be-added-to-CC++.html#extended). It’s a variation on the extremely common belief that C and C++ are the…">
		<meta property="og:site_name" content="Good Math, Bad Math">
		<meta name="pinterest" content="nopin">

	
<!-- Development by Crowd Favorite - http://crowdfavorite.com/ -->
<link rel="alternate" type="application/rss+xml" title="Good Math, Bad Math » Feed" href="http://scienceblogs.com/goodmath/feed/">
<link rel="alternate" type="application/rss+xml" title="Good Math, Bad Math » Comments Feed" href="http://scienceblogs.com/goodmath/comments/feed/">
<link rel="alternate" type="application/rss+xml" title="Good Math, Bad Math » The “C is Efficient” Language Fallacy Comments Feed" href="http://scienceblogs.com/goodmath/2006/11/02/the-c-is-efficient-language-fa/feed/">
<style type="text/css" media="screen">.cfpg-gallery img { display: none; }</style>
<noscript><style type="text/css" media="screen">.cfpg-gallery img { display: inline-block; }</style></noscript>
<link rel="stylesheet" id="ngssb-base-css" href="the-c-is-efficient-language-fallacy_files/css.css" type="text/css" media="screen">
<link rel="stylesheet" id="ngs-scienceblogs-css" href="the-c-is-efficient-language-fallacy_files/style.css" type="text/css" media="screen">
<!--[if lte IE 7]>
<link rel='stylesheet' id='ngs-ie7-css'  href='http://scienceblogs.com/goodmath/wp-content/themes/ngs-science-blogs/ngs-science-blogs-base/css/lte-ie7.css?ver=1.4.3.4' type='text/css' media='screen' />
<![endif]-->
<!--[if lte IE 6]>
<link rel='stylesheet' id='ngs-ie6-css'  href='http://scienceblogs.com/goodmath/wp-content/themes/ngs-science-blogs/ngs-science-blogs-base/css/lte-ie6.css?ver=1.4.3.4' type='text/css' media='screen' />
<![endif]-->
<script src="the-c-is-efficient-language-fallacy_files/beacon.js" async=""></script><script src="the-c-is-efficient-language-fallacy_files/ga.js" async="" type="text/javascript"></script><script type="text/javascript" src="the-c-is-efficient-language-fallacy_files/jquery_003.js"></script>
<script type="text/javascript" src="the-c-is-efficient-language-fallacy_files/jquery-migrate.js"></script>
<script type="text/javascript" src="the-c-is-efficient-language-fallacy_files/jquery.js"></script>
<script type="text/javascript" src="the-c-is-efficient-language-fallacy_files/master.js"></script>
<script type="text/javascript">
	jQuery(function ($) {
		var widget = $(".widget-ngs-collapsible");
		if (widget.length < 1) { return; };
		widget.find(".widget-title").click(function () {
			var widget = $(this).parent(),
				content = widget.find(".textwidget"),
				isVisible = content.is(":visible"),
				f = isVisible ? "slideUp" : "slideDown",
				c = isVisible ? "removeClass" : "addClass";
			widget[c]("widget-ngs-collapsible-open");
			content[f]("fast");
		});
	});
</script><link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://scienceblogs.com/goodmath/xmlrpc.php?rsd">
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://scienceblogs.com/goodmath/wp-includes/wlwmanifest.xml"> 
<link rel="prev" title="ISCID and the Definition of Specified Complexity" href="http://scienceblogs.com/goodmath/2006/11/01/iscid-and-the-definition-of-sp/">
<link rel="next" title="Vote for Shelley! (Blogging Scholarships)" href="http://scienceblogs.com/goodmath/2006/11/03/vote-for-shelley-blogging-scho/">
<meta name="generator" content="WordPress 3.6.2-alpha">
<link rel="canonical" href="http://scienceblogs.com/goodmath/2006/11/02/the-c-is-efficient-language-fa/">
<link rel="shortlink" href="http://scienceblogs.com/goodmath/?p=201">
<link rel="icon" type="image/x-icon" href="http://scienceblogs.com/goodmath/wp-content/themes/ngs-science-blogs/ngs-science-blogs-base/img/sbfavicon.ico">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
	<style type="text/css">.recentcomments a{display:inline !important;padding:0 !important;margin:0 !important;}</style>
	<style type="text/css">.recentcomments a{display:inline !important;padding:0 !important;margin:0 !important;}</style>
<!--
	generated in 2.320 seconds
	309480 bytes batcached for 600 seconds
-->
<style type="text/css">.fb_hidden{position:absolute;top:-10000px;z-index:10001}
.fb_invisible{display:none}
.fb_reset{background:none;border:0;border-spacing:0;color:#000;cursor:auto;direction:ltr;font-family:"lucida grande", tahoma, verdana, arial, sans-serif;font-size:11px;font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:1;margin:0;overflow:visible;padding:0;text-align:left;text-decoration:none;text-indent:0;text-shadow:none;text-transform:none;visibility:visible;white-space:normal;word-spacing:normal}
.fb_reset > div{overflow:hidden}
.fb_link img{border:none}
.fb_dialog{background:rgba(82, 82, 82, .7);position:absolute;top:-10000px;z-index:10001}
.fb_dialog_advanced{padding:10px;-moz-border-radius:8px;-webkit-border-radius:8px;border-radius:8px}
.fb_dialog_content{background:#fff;color:#333}
.fb_dialog_close_icon{background:url(http://static.ak.fbcdn.net/rsrc.php/v2/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 0 transparent;_background-image:url(http://static.ak.fbcdn.net/rsrc.php/v2/yL/r/s816eWC-2sl.gif);cursor:pointer;display:block;height:15px;position:absolute;right:18px;top:17px;width:15px;top:8px\9;right:7px\9}
.fb_dialog_mobile .fb_dialog_close_icon{top:5px;left:5px;right:auto}
.fb_dialog_padding{background-color:transparent;position:absolute;width:1px;z-index:-1}
.fb_dialog_close_icon:hover{background:url(http://static.ak.fbcdn.net/rsrc.php/v2/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 -15px transparent;_background-image:url(http://static.ak.fbcdn.net/rsrc.php/v2/yL/r/s816eWC-2sl.gif)}
.fb_dialog_close_icon:active{background:url(http://static.ak.fbcdn.net/rsrc.php/v2/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 -30px transparent;_background-image:url(http://static.ak.fbcdn.net/rsrc.php/v2/yL/r/s816eWC-2sl.gif)}
.fb_dialog_loader{background-color:#f2f2f2;border:1px solid #606060;font-size:24px;padding:20px}
.fb_dialog_top_left,
.fb_dialog_top_right,
.fb_dialog_bottom_left,
.fb_dialog_bottom_right{height:10px;width:10px;overflow:hidden;position:absolute}
.fb_dialog_top_left{background:url(http://static.ak.fbcdn.net/rsrc.php/v2/ye/r/8YeTNIlTZjm.png) no-repeat 0 0;left:-10px;top:-10px}
.fb_dialog_top_right{background:url(http://static.ak.fbcdn.net/rsrc.php/v2/ye/r/8YeTNIlTZjm.png) no-repeat 0 -10px;right:-10px;top:-10px}
.fb_dialog_bottom_left{background:url(http://static.ak.fbcdn.net/rsrc.php/v2/ye/r/8YeTNIlTZjm.png) no-repeat 0 -20px;bottom:-10px;left:-10px}
.fb_dialog_bottom_right{background:url(http://static.ak.fbcdn.net/rsrc.php/v2/ye/r/8YeTNIlTZjm.png) no-repeat 0 -30px;right:-10px;bottom:-10px}
.fb_dialog_vert_left,
.fb_dialog_vert_right,
.fb_dialog_horiz_top,
.fb_dialog_horiz_bottom{position:absolute;background:#525252;filter:alpha(opacity=70);opacity:.7}
.fb_dialog_vert_left,
.fb_dialog_vert_right{width:10px;height:100%}
.fb_dialog_vert_left{margin-left:-10px}
.fb_dialog_vert_right{right:0;margin-right:-10px}
.fb_dialog_horiz_top,
.fb_dialog_horiz_bottom{width:100%;height:10px}
.fb_dialog_horiz_top{margin-top:-10px}
.fb_dialog_horiz_bottom{bottom:0;margin-bottom:-10px}
.fb_dialog_iframe{line-height:0}
.fb_dialog_content .dialog_title{background:#6d84b4;border:1px solid #3b5998;color:#fff;font-size:14px;font-weight:bold;margin:0}
.fb_dialog_content .dialog_title > span{background:url(http://static.ak.fbcdn.net/rsrc.php/v2/yd/r/Cou7n-nqK52.gif)
no-repeat 5px 50%;float:left;padding:5px 0 7px 26px}
body.fb_hidden{-webkit-transform:none;height:100%;margin:0;overflow:visible;position:absolute;top:-10000px;left:0;width:100%}
.fb_dialog.fb_dialog_mobile.loading{background:url(http://static.ak.fbcdn.net/rsrc.php/v2/ya/r/3rhSv5V8j3o.gif)
white no-repeat 50% 50%;min-height:100%;min-width:100%;overflow:hidden;position:absolute;top:0;z-index:10001}
.fb_dialog.fb_dialog_mobile.loading.centered{max-height:590px;min-height:590px;max-width:500px;min-width:500px}
#fb-root #fb_dialog_ipad_overlay{background:rgba(0, 0, 0, .45);position:absolute;left:0;top:0;width:100%;min-height:100%;z-index:10000}
#fb-root #fb_dialog_ipad_overlay.hidden{display:none}
.fb_dialog.fb_dialog_mobile.loading iframe{visibility:hidden}
.fb_dialog_content .dialog_header{-webkit-box-shadow:white 0 1px 1px -1px inset;background:-webkit-gradient(linear, 0% 0%, 0% 100%, from(#738ABA), to(#2C4987));border-bottom:1px solid;border-color:#1d4088;color:#fff;font:14px Helvetica, sans-serif;font-weight:bold;text-overflow:ellipsis;text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0;vertical-align:middle;white-space:nowrap}
.fb_dialog_content .dialog_header table{-webkit-font-smoothing:subpixel-antialiased;height:43px;width:100%
}
.fb_dialog_content .dialog_header td.header_left{font-size:12px;padding-left:5px;vertical-align:middle;width:60px
}
.fb_dialog_content .dialog_header td.header_right{font-size:12px;padding-right:5px;vertical-align:middle;width:60px
}
.fb_dialog_content .touchable_button{background:-webkit-gradient(linear, 0% 0%, 0% 100%, from(#4966A6),
color-stop(0.5, #355492), to(#2A4887));border:1px solid #29447e;-webkit-background-clip:padding-box;-webkit-border-radius:3px;-webkit-box-shadow:rgba(0, 0, 0, .117188) 0 1px 1px inset,
rgba(255, 255, 255, .167969) 0 1px 0;display:inline-block;margin-top:3px;max-width:85px;line-height:18px;padding:4px 12px;position:relative}
.fb_dialog_content .dialog_header .touchable_button input{border:none;background:none;color:#fff;font:12px Helvetica, sans-serif;font-weight:bold;margin:2px -12px;padding:2px 6px 3px 6px;text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0}
.fb_dialog_content .dialog_header .header_center{color:#fff;font-size:16px;font-weight:bold;line-height:18px;text-align:center;vertical-align:middle}
.fb_dialog_content .dialog_content{background:url(http://static.ak.fbcdn.net/rsrc.php/v2/y9/r/jKEcVPZFk-2.gif) no-repeat 50% 50%;border:1px solid #555;border-bottom:0;border-top:0;height:150px}
.fb_dialog_content .dialog_footer{background:#f2f2f2;border:1px solid #555;border-top-color:#ccc;height:40px}
#fb_dialog_loader_close{float:left}
.fb_dialog.fb_dialog_mobile .fb_dialog_close_button{text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0}
.fb_dialog.fb_dialog_mobile .fb_dialog_close_icon{visibility:hidden}
.fb_iframe_widget{display:inline-block;position:relative}
.fb_iframe_widget span{display:inline-block;position:relative;text-align:justify}
.fb_iframe_widget iframe{position:absolute}
.fb_iframe_widget_lift{z-index:1}
.fb_hide_iframes iframe{position:relative;left:-10000px}
.fb_iframe_widget_loader{position:relative;display:inline-block}
.fb_iframe_widget_fluid{display:inline}
.fb_iframe_widget_fluid span{width:100%}
.fb_iframe_widget_loader iframe{min-height:32px;z-index:2;zoom:1}
.fb_iframe_widget_loader .FB_Loader{background:url(http://static.ak.fbcdn.net/rsrc.php/v2/y9/r/jKEcVPZFk-2.gif) no-repeat;height:32px;width:32px;margin-left:-16px;position:absolute;left:50%;z-index:4}
.fb_connect_bar_container div,
.fb_connect_bar_container span,
.fb_connect_bar_container a,
.fb_connect_bar_container img,
.fb_connect_bar_container strong{background:none;border-spacing:0;border:0;direction:ltr;font-style:normal;font-variant:normal;letter-spacing:normal;line-height:1;margin:0;overflow:visible;padding:0;text-align:left;text-decoration:none;text-indent:0;text-shadow:none;text-transform:none;visibility:visible;white-space:normal;word-spacing:normal;vertical-align:baseline}
.fb_connect_bar_container{position:fixed;left:0 !important;right:0 !important;height:42px !important;padding:0 25px !important;margin:0 !important;vertical-align:middle !important;border-bottom:1px solid #333 !important;background:#3b5998 !important;z-index:99999999 !important;overflow:hidden !important}
.fb_connect_bar_container_ie6{position:absolute;top:expression(document.compatMode=="CSS1Compat"? document.documentElement.scrollTop+"px":body.scrollTop+"px")}
.fb_connect_bar{position:relative;margin:auto;height:100%;width:100%;padding:6px 0 0 0 !important;background:none;color:#fff !important;font-family:"lucida grande", tahoma, verdana, arial, sans-serif !important;font-size:13px !important;font-style:normal !important;font-variant:normal !important;font-weight:normal !important;letter-spacing:normal !important;line-height:1 !important;text-decoration:none !important;text-indent:0 !important;text-shadow:none !important;text-transform:none !important;white-space:normal !important;word-spacing:normal !important}
.fb_connect_bar a:hover{color:#fff}
.fb_connect_bar .fb_profile img{height:30px;width:30px;vertical-align:middle;margin:0 6px 5px 0}
.fb_connect_bar div a,
.fb_connect_bar span,
.fb_connect_bar span a{color:#bac6da;font-size:11px;text-decoration:none}
.fb_connect_bar .fb_buttons{float:right;margin-top:7px}
.fb_edge_widget_with_comment{position:relative;*z-index:1000}
.fb_edge_widget_with_comment span.fb_edge_comment_widget{position:absolute}
.fb_edge_widget_with_comment span.fb_send_button_form_widget{z-index:1}
.fb_edge_widget_with_comment span.fb_send_button_form_widget .FB_Loader{left:0;top:1px;margin-top:6px;margin-left:0;background-position:50% 50%;background-color:#fff;height:150px;width:394px;border:1px #666 solid;border-bottom:2px solid #283e6c;z-index:1}
.fb_edge_widget_with_comment span.fb_send_button_form_widget.dark .FB_Loader{background-color:#000;border-bottom:2px solid #ccc}
.fb_edge_widget_with_comment span.fb_send_button_form_widget.siderender
.FB_Loader{margin-top:0}
.fbpluginrecommendationsbarleft,
.fbpluginrecommendationsbarright{position:fixed !important;bottom:0;z-index:999}
.fbpluginrecommendationsbarleft{left:10px}
.fbpluginrecommendationsbarright{right:10px}</style></head>
<body data-twttr-rendered="true" class="single single-post postid-201 single-format-standard science-blogs"><iframe src="the-c-is-efficient-language-fallacy_files/hub.html" style="position: absolute; top: -9999em; width: 10px; height: 10px;" name="twttrHubFrameSecure" tabindex="0" allowtransparency="true" id="twttrHubFrameSecure" scrolling="no" frameborder="0"></iframe><iframe src="the-c-is-efficient-language-fallacy_files/hub_002.html" style="position: absolute; top: -9999em; width: 10px; height: 10px;" name="twttrHubFrame" tabindex="0" allowtransparency="true" id="twttrHubFrame" scrolling="no" frameborder="0"></iframe>
	<div id="body">
				
				<!--<div id="navigation_tophat_container"> 			
			<div class="vcard" id="header_logo"> 
				<h2 class="org"><a href="http://www.nationalgeographic.com" class="url fn hiddenText" id="intl_link_headerboard_logo">National Geographic Society</a><span class="partner-text">In partnership with</span></h2> 
				<p class="adr hidden"> 
					<span class="street-address">P.O. Box 98199</span><br/> 
					<span class="locality">Washington</span>, <abbr title="District of Columbia" class="region">DC</abbr> <span class="postal_code">20090-8199</span><br/> 
					<span class="tel hidden">800-647-5463</span> 
				</p> 
				<p class="geo hidden">Lat/Lon:
					<span class="latitude">38.90531943278526</span>,
					<span class="longitude">-77.0376992225647</span> 
				</p> 
			</div><!-- #header_logo -->	
		<!-- </div><!-- #navigation_tophat_container -->
		
		<div class="header-wrapper">
		
			<!-- HEADER ADVERTISEMENT --> 
			<div id="headerboard" class="clearfix"> 
				<div class="leaderboard advertisement sb-ad">
					<h3 class="hidden">Advertisement</h3>
					<!-- advertising --> 					
					
<div class="ad-728x90">
	
<script type="text/javascript"><!--
google_ad_client = "ca-pub-2369179702655127";
/* SB leaderboard */
google_ad_slot = "9405760593";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>

<script type="text/javascript" src="the-c-is-efficient-language-fallacy_files/show_ads.js"></script>

</div> 				</div><!-- .leaderboard .advertisement -->
			</div><!-- #headerboard -->
		
		
		<div id="header">
			<a href="http://scienceblogs.com/"><h1>Science Blogs</h1></a>
			<div class="go-to-blog">
				<form action="" method="" id="blog-nav">
					<label for="blog-list">Go to</label>
					<select id="blog-list">
			<option selected="selected" value="0">Select Blog...</option>

			<option value="http://scienceblogs.com/">ScienceBlogs Home</option>
			<optgroup label="ScienceBlogs"><option value="http://scienceblogs.com/aardvarchaeology/">Aardvarchaeology</option><option value="http://scienceblogs.com/aetiology/">Aetiology</option><option value="http://scienceblogs.com/illconsidered/">A Few Things Ill Considered</option><option value="http://scienceblogs.com/brookhaven/">Brookhaven Bits &amp; Bytes</option><option value="http://scienceblogs.com/builtonfacts/">Built on Facts</option><option value="http://scienceblogs.com/casaubonsbook/">Casaubon's Book</option><option value="http://scienceblogs.com/classm/">Class M</option><option value="http://scienceblogs.com/commonknowledge/">Common Knowledge</option><option value="http://scienceblogs.com/confessions/">Confessions of a Science Librarian</option><option value="http://scienceblogs.com/deanscorner/">Dean's Corner</option><option value="http://scienceblogs.com/deltoid/">Deltoid</option><option value="http://scienceblogs.com/denialism/">denialism blog</option><option value="http://scienceblogs.com/developingintelligence/">Developing Intelligence</option><option value="http://scienceblogs.com/digitalbio/">Discovering Biology in a Digital World</option><option value="http://scienceblogs.com/catdynamics/">Dynamics of Cats</option><option value="http://scienceblogs.com/effectmeasure/">Effect Measure</option><option value="http://scienceblogs.com/erv/">erv</option><option value="http://scienceblogs.com/evolutionblog/">EvolutionBlog</option><option value="http://scienceblogs.com/evolution/">Evolution for Everyone</option><option value="http://scienceblogs.com/gregladen/">Greg Laden's Blog</option><option value="http://scienceblogs.com/SETI/">Life at the SETI Institute</option><option value="http://scienceblogs.com/lifelines/">Life Lines</option><option value="http://scienceblogs.com/omnibrain/">Omni Brain</option><option value="http://scienceblogs.com/seed/">Page 3.14</option><option value="http://scienceblogs.com/pharyngula/">Pharyngula</option><option value="http://scienceblogs.com/insolence/">Respectful Insolence</option><option value="http://scienceblogs.com/sciencepunk/">SciencePunk</option><option value="http://scienceblogs.com/significantfigures/">Significant Figures by Peter Gleick</option><option value="http://scienceblogs.com/startswithabang/">Starts With A Bang</option><option value="http://scienceblogs.com/stoat/">Stoat</option><option value="http://scienceblogs.com/corpuscallosum/">The Corpus Callosum</option><option value="http://scienceblogs.com/thepumphandle/">The Pump Handle</option><option value="http://scienceblogs.com/weizmann/">The Weizmann Wave</option><option value="http://scienceblogs.com/tfk/">Thoughts from Kansas</option><option value="http://scienceblogs.com/principles/">Uncertain Principles</option><option value="http://scienceblogs.com/universe/">Universe</option><option value="http://scienceblogs.com/usasciencefestival/">USA Science and Engineering Festival: The Blog</option><option value="http://scienceblogs.com/worldsfair/">World's Fair</option><option value="http://scienceblogs.com/zooillogix/">Zooillogix</option></optgroup><optgroup label="Archives"><option value="http://scienceblogs.com/worldsciencefestival/">2010 World Science Festival Blog</option><option value="http://scienceblogs.com/clock/">A Blog Around The Clock</option><option value="http://scienceblogs.com/ethicsandscience/">Adventures in Ethics and Science</option><option value="http://scienceblogs.com/agoodpoop/">A Good Poop</option><option value="http://scienceblogs.com/stressrelated/">All of My Faults Are Stress Related</option><option value="http://scienceblogs.com/angrytoxicologist/">Angry Toxicologist</option><option value="http://scienceblogs.com/appliedstatistics/">Applied Statistics</option><option value="http://scienceblogs.com/art_of_science_learning/">Art of Science Learning</option><option value="http://scienceblogs.com/voteforscience/">A Vote For Science</option><option value="http://scienceblogs.com/basicconcepts/">Basic Concepts in Science</option><option value="http://scienceblogs.com/bioephemera/">bioephemera</option><option value="http://scienceblogs.com/bloggingtheorigin/">Blogging the Origin</option><option value="http://scienceblogs.com/chaoticutopia/">Chaotic Utopia</option><option value="http://scienceblogs.com/christinaslisrant/">Christina's LIS Rant</option><option value="http://scienceblogs.com/cognitivedaily/">Cognitive Daily</option><option value="http://scienceblogs.com/culturedish/">Culture Dish</option><option value="http://scienceblogs.com/deepseanews/">Deep Sea News</option><option value="http://scienceblogs.com/dispatches/">Dispatches from the Creation Wars</option><option value="http://scienceblogs.com/dotphysics/">Dot Physics</option><option value="http://scienceblogs.com/bushwells/">Dr. Joan Bushwell's Chimpanzee Refuge</option><option value="http://scienceblogs.com/eruptions/">Eruptions</option><option value="http://scienceblogs.com/evolgen/">evolgen</option><option value="http://scienceblogs.com/evolvingthoughts/">Evolving Thoughts</option><option value="http://scienceblogs.com/framing-science/">Framing Science</option><option value="http://scienceblogs.com/interactions/">Galactic Interactions</option><option value="http://scienceblogs.com/gnxp/">Gene Expression</option><option value="http://scienceblogs.com/geneticfuture/">Genetic Future</option><option value="http://scienceblogs.com/goodmath/">Good Math, Bad Math</option><option value="http://scienceblogs.com/greengabbro/">Green Gabbro</option><option value="http://scienceblogs.com/guiltyplanet/">Guilty Planet</option><option value="http://scienceblogs.com/integrityofscience/">Integrity of Science</option><option value="http://scienceblogs.com/intelisef/">Intel ISEF</option><option value="http://scienceblogs.com/laelaps/">Laelaps</option><option value="http://scienceblogs.com/grrlscientist/">Living the Scientific Life (Scientist, Interrupted)</option><option value="http://scienceblogs.com/mikethemadbiologist/">Mike the Mad Biologist</option><option value="http://scienceblogs.com/mixingmemory/">Mixing Memory</option><option value="http://scienceblogs.com/moleculeoftheday/">Molecule of the Day</option><option value="http://scienceblogs.com/myrmecos/">Myrmecos</option><option value="http://scienceblogs.com/neuronculture/">Neuron Culture</option><option value="http://scienceblogs.com/neurontic/">Neurontic</option><option value="http://scienceblogs.com/neurophilosophy/">Neurophilosophy</option><option value="http://scienceblogs.com/neurotopia/">Neurotopia</option><option value="http://scienceblogs.com/notrocketscience/">Not Exactly Rocket Science</option><option value="http://scienceblogs.com/obesitypanacea/">Obesity Panacea</option><option value="http://scienceblogs.com/observations/">Observations of a Nerd</option><option value="http://scienceblogs.com/twominds/">Of Two Minds</option><option value="http://scienceblogs.com/isisthescientist/">On Becoming a Domestic and Laboratory Goddess</option><option value="http://scienceblogs.com/oscillator/">Oscillator</option><option value="http://scienceblogs.com/photosynthesis/">Photo Synthesis</option><option value="http://scienceblogs.com/purepedantry/">Pure Pedantry</option><option value="http://scienceblogs.com/retrospectacle/">Retrospectacle: A Neuroscience Blog</option><option value="http://scienceblogs.com/revminds/">Revolutionary Minds Think Tank</option><option value="http://scienceblogs.com/sciencesociety/">Science + Society</option><option value="http://scienceblogs.com/sunclipse/">Science After Sunclipse</option><option value="http://scienceblogs.com/scienceisculture/">Science is Culture</option><option value="http://scienceblogs.com/scienceonline/">ScienceOnline 2010: The Blog</option><option value="http://scienceblogs.com/sciencetolife/">Science To Life</option><option value="http://scienceblogs.com/sciencewoman/">Sciencewomen</option><option value="http://scienceblogs.com/seedmoma/">Seed/MoMA Salon</option><option value="http://scienceblogs.com/seejanecompute/">See Jane Compute</option><option value="http://scienceblogs.com/shiftingbaselines/">Shifting Baselines</option><option value="http://scienceblogs.com/signout/">Signout</option><option value="http://scienceblogs.com/speakeasyscience/">Speakeasy Science</option><option value="http://scienceblogs.com/speakingscience/">Speaking Science 2.0</option><option value="http://scienceblogs.com/strangerfruit/">Stranger Fruit</option><option value="http://scienceblogs.com/superbug/">Superbug</option><option value="http://scienceblogs.com/terrasig/">Terra Sigillata</option><option value="http://scienceblogs.com/tetrapodzoology/">Tetrapod Zoology</option><option value="http://scienceblogs.com/challenge/">The Blogger SAT Challenge</option><option value="http://scienceblogs.com/bookoftrogool/">The Book of Trogool</option><option value="http://scienceblogs.com/thecheerfuloncologist/">The Cheerful Oncologist</option><option value="http://scienceblogs.com/drcharlesHIDDEN/">The Examining Room of Dr. Charles</option><option value="http://scienceblogs.com/cortex/">The Frontal Cortex</option><option value="http://scienceblogs.com/intersection/">The Intersection</option><option value="http://scienceblogs.com/islandofdoubt/">The Island of Doubt</option><option value="http://scienceblogs.com/loom/">The Loom</option><option value="http://scienceblogs.com/primatediaries/">The Primate Diaries</option><option value="http://scienceblogs.com/pontiff/">The Quantum Pontiff</option><option value="http://scienceblogs.com/authority/">The Questionable Authority</option><option value="http://scienceblogs.com/rightfulplace/">The Rightful Place Project</option><option value="http://scienceblogs.com/bookclub/">The ScienceBlogs Book Club</option><option value="http://scienceblogs.com/scientificactivist/">The Scientific Activist</option><option value="http://scienceblogs.com/thescian/">The Scientific Indian</option><option value="http://scienceblogs.com/thoughtfulanimal/">The Thoughtful Animal</option><option value="http://scienceblogs.com/voltagegate/">The Voltage Gate</option><option value="http://scienceblogs.com/thusspakezuska/">Thus Spake Zuska</option><option value="http://scienceblogs.com/tomorrowstable/">Tomorrow's Table</option><option value="http://scienceblogs.com/transcript/">Transcription and Translation</option><option value="http://scienceblogs.com/waltatrandom/">Walt at Random</option><option value="http://scienceblogs.com/webeasties/">We Beasties</option><option value="http://scienceblogs.com/whitecoatunderground/">White Coat Underground</option></optgroup></select>
	<script type="text/javascript">
	/* <![CDATA[ */
		var ngssbBLDropdown = document.getElementById("blog-list");
		function ngssbBLChange() {
				location.href = ngssbBLDropdown.options[ngssbBLDropdown.selectedIndex].value;
		}
		ngssbBLDropdown.onchange = ngssbBLChange;
	/* ]]> */
	</script>				</form>
			</div>

			<form role="search" method="get" id="header_search" action="http://scienceblogs.com/">
				<h2 class="hidden">Search National Geographic</h2> 
				<!-- google search parameters --> 
				<div class="field"> 
					<label for="header_search_input">Search <span class="hidden">nationalgeographic.com</span></label> 
					<input name="s" id="s" type="text">
					<button type="submit" id="header_search_submit" class="hiddenText">Submit</button> 
				</div> 
			</form><!-- #header_search -->
			<div class="main-nav-wrapper">
				<ul id="navigation_mainB" class="nav">
					<li id="nav-item1"><a href="http://scienceblogs.com/last-24-hours">Last 24 Hrs</a></li><li id="nav-item2"><a href="http://scienceblogs.com/channel/life-science/">Life Science</a></li><li id="nav-item3"><a href="http://scienceblogs.com/channel/physical-science/">Physical Science</a></li><li id="nav-item4"><a href="http://scienceblogs.com/channel/environment/">Environment</a></li><li id="nav-item5"><a href="http://scienceblogs.com/channel/humanities/">Humanities</a></li><li id="nav-item6"><a href="http://scienceblogs.com/channel/education/">Education</a></li><li id="nav-item7"><a href="http://scienceblogs.com/channel/politics/">Politics</a></li><li id="nav-item8"><a href="http://scienceblogs.com/channel/medicine/">Medicine</a></li><li id="nav-item9"><a href="http://scienceblogs.com/channel/brain-and-behavior/">Brain &amp; Behavior</a></li><li id="nav-item10"><a href="http://scienceblogs.com/channel/technology/">Technology</a></li><li id="nav-item11"><a href="http://scienceblogs.com/channel/information-science/">Information Science</a></li><li class="last" id="nav-item12"><a href="http://scienceblogs.com/channel/jobs/">Jobs</a></li>				</ul>
			</div><!--/main-nav-wrapper-->
		</div><!--/header-->
	</div><!--/header-wrapper-->
<div id="main">
	<div class="str-inside clearfix">		
		<div id="content">
			<h1 class="blog-title"><a href="http://scienceblogs.com/goodmath/">Good Math, Bad Math</a></h1><div id="post-201" class="post-201 post type-post status-publish format-standard hentry category-programming post-full clearfix">
	<div class="header">
	<h1 class="title entry-title"><a rel="bookmark" href="http://scienceblogs.com/goodmath/2006/11/02/the-c-is-efficient-language-fa/">The “C is Efficient” Language Fallacy</a></h1>
	<div class="byline vcard author">
		
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4_002.jpeg" class="avatar avatar-58 photo" height="58" width="58">Posted by <span class="fn"><a href="http://scienceblogs.com/goodmath/author/goodmath/" title="Posts by Mark C. Chu-Carroll">Mark C. Chu-Carroll</a></span> on <abbr class="published" title="2006-11-02T09:31:28+00:00">November 2, 2006</abbr> 	</div><!--/byline-->
</div><!--/header-->


<div class="box-share">
	<div class="comments">
		<a href="http://scienceblogs.com/goodmath/2006/11/02/the-c-is-efficient-language-fa/#comments" rev="post-201" class="to-comments" title="Comment on The “C is Efficient” Language Fallacy">(169)</a>	</div>
	<div class="addthis_toolbox addthis_default_style" addthis:url="http://scienceblogs.com/goodmath/2006/11/02/the-c-is-efficient-language-fa/" addthis:title="The “C is Efficient” Language Fallacy">
		<a class="addthis_button_facebook_like at300b" fb:like:layout="button_count" style="opacity:1;"><div fb-xfbml-state="rendered" data-send="false" data-href="http://scienceblogs.com/goodmath/2006/11/02/the-c-is-efficient-language-fa/" data-font="arial" data-width="90" data-action="like" data-show_faces="false" data-layout="button_count" class="fb-like fb_edge_widget_with_comment fb_iframe_widget" data-ref=".UodpilZv9e4.like"><span style="height: 21px; width: 73px;"><iframe src="the-c-is-efficient-language-fallacy_files/like.html" class="fb_ltr" title="Like this content on Facebook." style="border: medium none; overflow: hidden; height: 21px; width: 73px;" name="f25b7bb232b3726" id="f3dba41036b14c8" scrolling="no"></iframe></span></div></a>
		<a class="addthis_button_tweet at300b" tw:via="Scienceblogs"><iframe style="width: 106px; height: 20px;" data-twttr-rendered="true" title="Twitter Tweet Button" class="twitter-share-button twitter-tweet-button twitter-count-horizontal" src="the-c-is-efficient-language-fallacy_files/tweet_button.html" allowtransparency="true" id="twitter-widget-0" scrolling="no" frameborder="0"></iframe></a>
		<a class="addthis_button_google_plusone at300b" g:plusone:size="medium"><div id="___plusone_0" style="text-indent: 0px; margin: 0px; padding: 0px; background: none repeat scroll 0% 0% transparent; border-style: none; float: none; line-height: normal; font-size: 1px; vertical-align: baseline; display: inline-block; width: 90px; height: 20px;"><iframe title="+1" data-gapiattached="true" src="the-c-is-efficient-language-fallacy_files/fastbutton.html" name="I0_1384606100056" id="I0_1384606100056" vspace="0" tabindex="0" style="position: static; top: 0px; width: 90px; margin: 0px; border-style: none; left: 0px; visibility: visible; height: 20px;" marginwidth="0" marginheight="0" hspace="0" scrolling="no" width="100%" frameborder="0"></iframe></div></a>
		<a href="#" title="Email" target="_blank" class="addthis_button_email at300b"><span class="at16nc at300bs at15nc at15t_email at16t_email"><span class="at_a11y">Share on email</span></span></a>
		<a title="View more services" target="_blank" href="#" class="addthis_button_expanded"><span></span>More »</a>
	<div class="atclear"></div></div>
</div>	<div class="main">
		<div class="content entry-content">
			<p>I came across an article yesterday about programming languages, which hit on one<br>
of  my major peeves, so I can’t resist responding. The article is at greythumb.org,<br>
and it’s called [Programmer's rant: what should and should not be added 
to 
C/C++](http://www.greythumb.org/blog/index.php?/archives/152-Programmers-rant-what-should-and-should-not-be-added-to-CC++.html#extended).</p>
<p>It’s a variation on the extremely common belief that C and C++ are 
the best languages to use when you need code to run fast. They’re not. 
They’re good at things that need to get very close to the hardware – not<br>
in the efficiency sense,  but in the sense of needing to be able to 
fairly directly munge the stack, address specific hardware registers, 
etc. But they are *dreadful* languages for writing real scientific 
and/or numerical code.</p>
<p><span id="more-201"></span><br>
To quote the part of the article that set me off:</p>
<p>&gt;First of all, these fears are nonsense. C and C++ are never going to disappear. Why? Because there<br>
&gt;are classes of programming problems that are still and will always be CPU bound and there is still<br>
&gt;no language as fast as C or C++ for these problems. I highly doubt that there ever will be.<br>
&gt;<br>
&gt;I’m talking about things like: scientific number crunching, game/simulation physics, raytracing,<br>
&gt;real-time 3d graphics, audio processing, codec implementation, high-speed network packet routing,<br>
&gt;evolutionary computation (my personal favorite <img src="the-c-is-efficient-language-fallacy_files/icon_smile.gif" alt=":)" class="wp-smiley"> , and of course implementing all these high-level<br>
&gt;languages’ runtimes. There are also problems like OS and hardware driver implementation where you<br>
&gt;need something “close to the metal” that can interact closely with and even embed assembly language.<br>
&gt;C is basically shorthand for assembler, which is why it’s the preferred language for that kind of<br>
&gt;thing.<br>
&gt;<br>
&gt;For these tasks, premature optimization at the level of language and framework choice is not evil.<br>
&gt;In some cases it’s a requirement. I predict that at least some of these tasks will still be done in<br>
&gt;C, C++, or some language with similar characteristics 50 years from now. To give you an idea of just<br>
&gt;how much faster C can be for tasks like this, I have found that evolvable instruction set based<br>
&gt;evolutionary computation is almost twice as fast when competently implemented in C than a similar<br>
&gt;competent implementation in Java.</p>
<p>Here’s the problem. C and C++ suck rocks as languages for numerical 
computing. They are *not* the fastest, not by a longshot.  In fact, the 
fundamental design of them makes it pretty much *impossible* to make 
really good, efficient code in C/C++. There’s a good reason that Fortran<br>
is still the language of choice for real, intense scientific applications that require the<br>
absolute best performance that can be drawn out of our machines – applications like computational fluid dynamics.</p>
<p>Making real applications run really fast is something that’s done 
with the help of a compiler. Modern architectures have reached the point
 where people can’t code effectively in assembler anymore – switching 
the order of two independent instructions can have a dramatic impact on 
performance in a modern machine, and the constraints that you need to 
optimize for are just more complicated than people can generally deal 
with. </p>
<p>So for modern systems, writing an efficient program is sort of a partnership. The human needs to<br>
careful choose algorithms – the machine can’t possibly do that. And the 
machine needs to carefully compute instruction ordering, pipeline 
constraints, memory fetch delays, etc. The two together can build really
 fast systems. But the two parts aren’t independent: the human needs to 
express the algorithm in a way that allows the compiler to understand it
 well enough to be able to really<br>
optimize it.</p>
<p>And that’s where C and C++ fall down. C and C++ are strongly pointer-based languages. The real<br>
semantics of almost anything interesting end up involving pretty much unrestricted pointers. In C and<br>
C++, there’s no such thing as an array – there’s just pointers, which you can subscript and a<br>
shorthand for pointer arithmetic and indirection(`x[n]` in C/C++ is the same thing as `*(x+n)`.) </p>
<p>That pointer based nature means that in a C or C++ program, it’s *very* hard for a compiler to figure<br>
out what things are independent. It comes down to a problem called 
*alias detection*. Alias detection is identifying when two variables 
*might* be referencing the same location. Alias detection becomes a 
horrific mess in the presence of unrestricted pointers. Let me show you 
an example:</p>
<p>    for (int i=0; i &lt; 20000) {<br>
       for (int j=0; j &lt; 20000) {<br>
          x[i][j] = y[i-2][j+1] * y[i+1][j-2];<br>
       }<br>
    }</p>
<p>If you look at that loop, it can be parallelized or vectorized 
without any problem *if* and *only if* the array pointed to by `x` and 
the array pointed to by `y` are completely distinct with no overlap. But
 there's no way to write code in C or C++ that guarantees that. If it 
were Fortran-77, you could easily check if they were distinct. If it 
were Fortran-98, you could check if `x` or `y` were declared as possible
 pointer targets, and the programmer could make it obvious that they 
didn't overlap if they wanted to. But you *can't* do that in C or C++. 
(And Fortran isn't even the best - an experimental language called Sisal
 from Lawrence Livermore labs used to be able to beat Fortran by around 
20% on typical code!)</p>
<p>That example involves parallelization of code, but alias related 
problems aren't just an issue for parallelism; it's just easiest to show
 an example for parallelism. The aliasing issues in C and C++ have a 
very direct impact on real code.</p>
<p>Let me tell you about a concrete example of this, and then I'll stop ranting. About six years ago, I<br>
was working on a project where I needed to implement a rather messy 
algorithm to compute something called the "longest common subsequence" 
(LCS) of two arrays. The standard algorithm for computing LCS is using 
something called dynamic programming; it's **O***(n<sup>3</sup>) time, and **O**(n<sup>2</sup>)
 space. There’s an algorithm that was designed by people doing 
computational biology that can do it in the same time, but using on 
average **O**(n) space. </p>
<p>I didn’t know what language to use for this project, so I decided to 
do an experiment. I wrote the LCS algorithm in a bunch of different 
languages, to compare how complex the code was, and how fast it ran. I 
wrote the comp bio algorithm in C, C++, OCaml, Java, and Python, and 
recorded the results. What I got timing-wise for running the programs on
 arrays of 2000 elements each was:</p>
<p>* C: 0.8 seconds.<br>
* C++: 2.3 seconds.<br>
* OCaml: 0.6 seconds *interpreted*, 0.3 seconds fully compiled.<br>
* Java: 1 minute 20 seconds.<br>
* Python: over 5 minutes.</p>
<p>About a year later, testing a new JIT for Java, the Java time was 
down to 0.7 seconds to run the code, plus about 1 second for the JVM to 
start up. (The startup times for C, C++, and Ocaml weren’t<br>
really measurable – they were smaller than the margin of error for the measurements.)</p>
<p>The Objective-Caml bytecode interpreter was faster than the carefully
 hand-optimized C program! Why? Because the OCaml compiler could 
recognize that the arrays were completely independent – it didn’t need 
to worry about one iteration of the loop stepping on the values used by 
another. The C compiler couldn’t apply a lot of useful optimizations, 
because it couldn’t be sure that they were valid. </p>
<p>And it’s not just non-assignment based functional languages where you can see supposedly<br>
less-efficient high level languages crushing the performance of C/C++. CMU CommonLisp can beat C/C++<br>
on numeric code. There was a paper a few years back documenting it: using a Sun SPARC workstation, if<br>
you use the optional type declarations, and write scientific/numeric code *in Lisp*, using vectors<br>
(Lisp arrays) and assignments to implement exactly the same algorithm as
 C, the CMU CommonLisp code will perform *better* than C code generated 
by either the Solaris C compiler or GCC with maximum optimization.</p>
		</div>
	</div>
	<div class="footer">
	
<div class="box-share">
	<div class="comments">
		<a href="http://scienceblogs.com/goodmath/2006/11/02/the-c-is-efficient-language-fa/#comments" rev="post-201" class="to-comments" title="Comment on The “C is Efficient” Language Fallacy">(169)</a>	</div>
	<div class="addthis_toolbox addthis_default_style" addthis:url="http://scienceblogs.com/goodmath/2006/11/02/the-c-is-efficient-language-fa/" addthis:title="The “C is Efficient” Language Fallacy">
		<a class="addthis_button_facebook_like at300b" fb:like:layout="button_count" style="opacity:1;"><div fb-xfbml-state="rendered" data-send="false" data-href="http://scienceblogs.com/goodmath/2006/11/02/the-c-is-efficient-language-fa/" data-font="arial" data-width="90" data-action="like" data-show_faces="false" data-layout="button_count" class="fb-like fb_edge_widget_with_comment fb_iframe_widget" data-ref=".Uodpinl0Rdk.like"><span style="height: 21px; width: 73px;"><iframe src="the-c-is-efficient-language-fallacy_files/like_002.html" class="fb_ltr" title="Like this content on Facebook." style="border: medium none; overflow: hidden; height: 21px; width: 73px;" name="f3c818a10125a6" id="f2e13d5b6179842" scrolling="no"></iframe></span></div></a>
		<a class="addthis_button_tweet at300b" tw:via="Scienceblogs"><iframe style="width: 106px; height: 20px;" data-twttr-rendered="true" title="Twitter Tweet Button" class="twitter-share-button twitter-tweet-button twitter-count-horizontal" src="the-c-is-efficient-language-fallacy_files/tweet_button_002.html" allowtransparency="true" id="twitter-widget-1" scrolling="no" frameborder="0"></iframe></a>
		<a class="addthis_button_google_plusone at300b" g:plusone:size="medium"><div id="___plusone_1" style="text-indent: 0px; margin: 0px; padding: 0px; background: none repeat scroll 0% 0% transparent; border-style: none; float: none; line-height: normal; font-size: 1px; vertical-align: baseline; display: inline-block; width: 90px; height: 20px;"><iframe title="+1" data-gapiattached="true" src="the-c-is-efficient-language-fallacy_files/fastbutton_002.html" name="I1_1384606100079" id="I1_1384606100079" vspace="0" tabindex="0" style="position: static; top: 0px; width: 90px; margin: 0px; border-style: none; left: 0px; visibility: visible; height: 20px;" marginwidth="0" marginheight="0" hspace="0" scrolling="no" width="100%" frameborder="0"></iframe></div></a>
		<a href="#" title="Email" target="_blank" class="addthis_button_email at300b"><span class="at16nc at300bs at15nc at15t_email at16t_email"><span class="at_a11y">Share on email</span></span></a>
		<a title="View more services" target="_blank" href="#" class="addthis_button_expanded"><span></span>More »</a>
	<div class="atclear"></div></div>
</div>	</div>
</div><!-- .excerpt --><div id="comments"><h2 class="section-title">Comments</h2><ol class="reply-list">
<li class="li-comment" id="li-comment-3798">
	<div class="div-comment" id="div-comment-3798">
<div id="comment-3798" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3798" title="comment permalink">#1</a></span>
		<span class="fn"><a href="http://www.sader-family.org/roller/page/ksader" rel="external nofollow" class="url">Keith Sader</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/7e6ee7bc26cac7c3f1edce27558ced3d.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Thanks for the breakdown.  I *used* to be a C/C++ purist, but I got over it.</p>
<p>All languages have their place in the Tao, but do not use COBOL if you can avoid it. <img src="the-c-is-efficient-language-fallacy_files/icon_smile.gif" alt=":-)" class="wp-smiley"> </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3799">
	<div class="div-comment" id="div-comment-3799">
<div id="comment-3799" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3799" title="comment permalink">#2</a></span>
		<span class="fn">Gaurav</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/392b55ab06fb53be5736f362d46092b4.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Mark</p>
<p>What is your take on languages/packages such as MATLAB, Mathematica and Maple? </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3800">
	<div class="div-comment" id="div-comment-3800">
<div id="comment-3800" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3800" title="comment permalink">#3</a></span>
		<span class="fn">Walker</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/ec5764de6f61bd31a39365aead5f6c68.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>I work with the ACM programming competition team here at Cornell.  
Lots of CPU bound programs in those competitions, and your program has 
to finish in 2 minutes to be accepted.  </p>
<p>Except for the start-up time, I have never seen any difference 
between Java/C/C++ that couldn’t be accounted for runtime 
initialization.  GUI and graphics code is a whole ‘nother deal, for 
obvious reasons.</p>
<p>OCAML is damn fast.  I have seen some reall nice network stack code 
written in it.  But I wouldn’t want to be doing applications in it.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3801">
	<div class="div-comment" id="div-comment-3801">
<div id="comment-3801" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3801" title="comment permalink">#4</a></span>
		<span class="fn">Mark Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Gaurav:</p>
<p>I haven’t personally used MATLAB, Maple, etc., so I don’t know  much 
about their performance characteristics. I know my father used MATLAB 
for data analysis a few years ago, but the stuff he was doing wasn’t 
supercomputer complexity, but statistical<br>
analysis of semiconductor production runs, so expressiveness was more important than efficiency. </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3802">
	<div class="div-comment" id="div-comment-3802">
<div id="comment-3802" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3802" title="comment permalink">#5</a></span>
		<span class="fn">Mark Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Walker:</p>
<p>In recent Java VMs, it seems that the performance of most things 
written in Java do end up being comparable to, or even better than, 
C/C++. The main thing in Java is the highly expensive startup – the JVM 
takes quite a bit of time to start up, *and* the performance ramps up 
gradually as the JIT compiler optimizes the code. Once the JIT 
stabilizes, the performance is often quite excellent.</p>
<p>OCaml is definitely screamingly fast, but I don’t see why you 
wouldn’t want to write apps in it. I’ve done a *lot* of programming in 
OCaml, including writing several rather substantial applications. (The 
open-source Stellation project which I led had its first complete 
prototype implemented in OCaml. It needed to be rewritten in Java 
because we wanted to submit it to Eclipse.org. The Java version was 
about six times longer for equivalent function, and it was much slower.)</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3803">
	<div class="div-comment" id="div-comment-3803">
<div id="comment-3803" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3803" title="comment permalink">#6</a></span>
		<span class="fn">dileffante</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/0af24b9aa6a3437d7b2a297f1ae3a0f6.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Thanks for the post, Mark, and specially for the experiment; I 
usually program sequence stuff, and discrete dynamics (automata, boolean
 networks), and only rarely truly numerical things. I’m a bit lazy about
 changing languages, though, but I’ll keep this in mind.</p>
<p>…and, I have an (only slightly OT) question, which I guess some 
fellow commenter could answer (?). I usually program in C++, and I like 
the Visual Studio IDE. Since I had to give up illegal software, I’m 
abandoning VS6 and moving to VS Express. What I don’t know is what they 
mean with the “managed” code of VC++ Express… Does it somehow go through
 MS’ virtual machine, like VB and C#?? Will my little hard-working 
console apps run as fast now as they did with VC6?</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3804">
	<div class="div-comment" id="div-comment-3804">
<div id="comment-3804" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3804" title="comment permalink">#7</a></span>
		<span class="fn">Mark Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>dileffante:</p>
<p>The managed code is code that compiles to the CLR, which is MSs 
virtual machine. But it optimizes through a JIT just like Java – the 
startup time will be slightly higher, but the JIT will rapidly make up 
for it. Long running applications should perform *better* than the 
old-fashioned C++ compiler, because the JIT compiler has more 
information available – it can use dynamic information to guide the 
optimization.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3805">
	<div class="div-comment" id="div-comment-3805">
<div id="comment-3805" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3805" title="comment permalink">#8</a></span>
		<span class="fn">KeithB</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/3e06e6943b3c48a3fe03adb079e15595.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>While I know that C compilers are really conservative about this, 
doesn’t it matter as to how x and y are declared?  After all if they are
 dclared as:<br>
int x[1000], y[1000];</p>
<p>then the compiler can know that they are independent.</p>
<p>However, if they are declared as part of the function definition, then yes, they could be overlapping.</p>
<p>In other languages though, couldn’t you have the same problem with sub arrays passed to functions?</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3806">
	<div class="div-comment" id="div-comment-3806">
<div id="comment-3806" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3806" title="comment permalink">#9</a></span>
		<span class="fn">billb</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/a9e257ca2ff9b3dd65ed1abe534fe05e.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Horseshit! Bollocks! <img src="the-c-is-efficient-language-fallacy_files/icon_smile.gif" alt=":)" class="wp-smiley"> </p>
<p>It’s entirely possible to tell the C or C++ compiler that you never 
alias or that you alias in a function-by-function basis. That, and alias
 analysis gets better in these compilers all the time. You’ve really 
overstated your case by a long shot on the aliasing front, Mark. Send me
 your LCS code, and I’ll take a crack at it.</p>
<p>Also, if you have core routines that are really important and take up
 a  large fraction of your code’s run time, you should probably write a 
hand-coded in assembly routine for each architecture that is important 
to you. In fact, you should probably have an expert from the CPU vendor 
do the coding for you, unless you happen to have an assembly expert 
laying around (e.g., K. Goto’s work on the BLAS). At that point, the 
glue language comes down to personal preference and expressiveness.</p>
<p>BTW, I’ve seen a number of these comparisions where an expert in one 
language does an implementation in several languages and, lo and behold,
 discovers that their favorite language wins out. It’s all the same 
computer underneath, so if you aren’t getting fast code in one language 
(that’s sufficiently expressive) IT’S YOUR FAULT (whether because you 
aren’t a good enough programmer in that language, don’t know your 
compiler well enough, or aren’t using the right compiler (the old 
Programming Language Shootout used GCC, which often gets its butt kicked
 by the Intel compiler on Intel machines)) not the language’s.</p>
<p>Finally, I’ve got a wicked fast parallel, unstructured (mesh), 3D, 
time-dependent CFD code that’s written in C++. It was originally a 
C/Fortan code (Fortran for the tight, important loops), and then it 
became a C-only and got about 5% faster. When we refactored it into C++ 
it gained another 5%. When we refactored the main matrix formation 
routines to be more compiler-like, we gained 5% in that part of the 
code.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3807">
	<div class="div-comment" id="div-comment-3807">
<div id="comment-3807" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3807" title="comment permalink">#10</a></span>
		<span class="fn">Mark Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>KeithB:</p>
<p>`int x[1000]` in C or C++ doesn’t have much meaning. It’s 
semantically equivalent to declaring “x” as  `int *x`. You can reassign X
 any time you want, to make it point to a different location.</p>
<p>And your point WRT function definitions is dead on: the compiler 
can’t do much optimization if the parameters to the function are 
pointers.</p>
<p>The reason why it’s often better in other languages is because they 
make it much harder to create situation where there’s ambigous aliasing.
 You *can* create cases where you can’t prove independence in other 
languages – but in C++, you can almost *never* prove independence; in 
Fortran, you can *usually* prove independence.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3808">
	<div class="div-comment" id="div-comment-3808">
<div id="comment-3808" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3808" title="comment permalink">#11</a></span>
		<span class="fn">Jake Ham</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/8e4390c4f24f97164e32ccbf1a5e7072.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>@ dileffante</p>
<p>The “managed” C++ code means that it is managed by the .Net VM. This 
also means that it will be compiled into MSIL (the .net intermediate 
language). There are benefits for doing this, the VM will watch for 
buffer overflows, and it can also talk with non-managed code.  How fast 
will this be? I am not sure, but I think that it is more directed for 
developing safe code than it is for speed.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3809">
	<div class="div-comment" id="div-comment-3809">
<div id="comment-3809" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3809" title="comment permalink">#12</a></span>
		<span class="fn">Anthony Arkles</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/8b7d409f99c562bf0e2746873e35831c.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>To Mark Chu-Carroll:</p>
<p>I think you’re mistaken about int x[1000] and int *x being 
equivalent.  I just tried two different things with GCC, and they both 
failed to compile:</p>
<p>int x[1000];<br>
int y[1000];</p>
<p>x = y;  /* fails with error: incompatible types in assignment */</p>
<p>x++; /* fails with error: wrong type argument to increment */</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3810">
	<div class="div-comment" id="div-comment-3810">
<div id="comment-3810" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3810" title="comment permalink">#13</a></span>
		<span class="fn">KeithB</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/3e06e6943b3c48a3fe03adb079e15595.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>I hope I am not teaching my grandmother to suck eggs, but the C faq has a whole section on pointers and arrays:<br>
<a href="http://c-faq.com/aryptr/index.html" rel="nofollow">http://c-faq.com/aryptr/index.html</a></p>
<p>6.1:<br>
I’m still mystified. Is a pointer a kind of array, or is an array a kind of pointer? </p>
<p>Answer:<br>
An array is not a pointer, nor vice versa. An array reference (that is, 
any mention of an array in a value context), turns into a pointer (see 
questions 6.2 and 6.3). </p>
<p>There are perhaps three ways to think about the situation: </p>
<p>Pointers can simulate arrays (though that’s not all; see question 4.1).<br>
There’s hardly such a thing as an array (it is, after all, a 
“second-class citizen”); the subscripting operator [] is in fact a 
pointer operator.<br>
At a higher level of abstraction, a pointer to a block of memory is 
effectively the same as an array (though this says nothing about other 
uses of pointers). </p>
<p>But, to reiterate, here are two ways not to think about it: </p>
<p>4. “They’re completely the same.” (False; see question 6.2.)<br>
5. “Arrays are constant pointers.” (False; see question 6.9.) </p>
<p>See also question 6.8. </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3811">
	<div class="div-comment" id="div-comment-3811">
<div id="comment-3811" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3811" title="comment permalink">#14</a></span>
		<span class="fn">Mark Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>billb:</p>
<p>How do you tell a C++ compiler that there’s no aliasing between two three dimensional arrays of floats?</p>
<p>I can’t give you the code I did the LCS tests on – as I said, it was 
six years ago! It’s somewhere on a backup tape, and I’d need to get 
permission from my employer to release it.</p>
<p>At the time, I had just come off of a project where I was part of a 
team implementing a C++ compiler. C++ was definitely my strongest 
language at the time. The code in all of the languages was as carefully 
hand-optimized as I could make it. (The 0.8 seconds for C code for the 
kind of LCS I was doing was amazing performance, much better than I 
expected from *any* of the implementations.)</p>
<p>I went into the experiment expecting C and C++ to both kick the butts
 of everything else, and I was trying to find out just how much penalty 
I’d pay by using one of the “higher level” languages. One of the big 
questions that I went into the experiment with was how much penalty 
would I pay for using C++ instead of C? (That is, I viewed C++ as higher
 level than C, because of things like templates, better typing, cleaner 
memory allocation/management, etc; and I wanted to know how much penalty
 I’d get from it compared to<br>
plain C, and where it fit into the scale of performance from what I 
expected to be fastest (C) to what I expected to be slowest (Python).</p>
<p>And as I said, I did my best to optimize the C, because I wanted the 
numbers to be *accurate*. I didn’t want to spend two years writing a 
system, and then get beaten up by my management because of poor 
performance relative to what I could have gotten from C. I seriously 
wanted to make sure that I wasn’t going to screw myself over, so I 
really wanted to compare the best that each language had to offer.</p>
<p>As I said above, at the time, I was a serious C++ coder; the  thing I
 coded immediately before the Stellation experiments was a very hairy 
template analysis for a C++ compiler – roughly 10,000 lines of code 
fitting into a 1.5million line codebase.  </p>
<p>And at the time, I had *never* used OCaml; I had used its 
predecessor, Caml-Light for some experiments about 4 years earlier. But I
 was *far* from a highly skilled Caml hacker. </p>
<p>The results were extremely surprising to me, and I did spend some 
time profiling to try to figure out just why the OCaml was so much 
faster. The specific reason was that the Caml code did some really 
clever stuff – it basically did something like local constant 
propagation that were based on<br>
be able to identify relations between subscripts used to access 
different arrays, and having done that, it could do some dramatic code 
rewriting that made it possible to merge loops, and hoist some local 
constants out of the restructured merged loop.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3812">
	<div class="div-comment" id="div-comment-3812">
<div id="comment-3812" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3812" title="comment permalink">#15</a></span>
		<span class="fn">dileffante</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/0af24b9aa6a3437d7b2a297f1ae3a0f6.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Thanks, Mark and Jake!</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3814">
	<div class="div-comment" id="div-comment-3814">
<div id="comment-3814" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3814" title="comment permalink">#16</a></span>
		<span class="fn"><a href="http://cleek.lunarpages.com/blogs" rel="external nofollow" class="url">cleek</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/2e41d52b2986c0c63a2f464e34b7b3f3.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>if a loop contains code that can be broken into parallel paths, but
 you don’t notice it, or you notice it but don’t change your algorithm 
to make use of that knowledge, it’s not the language’s fault – it’s your
 fault.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3815">
	<div class="div-comment" id="div-comment-3815">
<div id="comment-3815" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3815" title="comment permalink">#17</a></span>
		<span class="fn">Mark</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/476058243b4d4368bb4e69784a85f7c2.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Nice to read this. All the youngsters around here make fun of me 
because I use Fortran;  most of them use C++. I am not a programmer, but
 anyone who works in my field has to be able to program to do the work 
and to make sense of the results of programs others write and provide.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3816">
	<div class="div-comment" id="div-comment-3816">
<div id="comment-3816" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3816" title="comment permalink">#18</a></span>
		<span class="fn"><a href="http://snews.bnl.gov/popsci/contents.html" rel="external nofollow" class="url">Blake Stacey</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/dd50e8b0462cc7fb7fa5bb0785e4f2a4.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>@Guarav:</p>
<p>Mathematica was legendary among MIT physics undergrads for being 
impossible to operate.  I don’t think I got a single thing to work with 
it that I didn’t redo more quickly in another language.  Of course, my 
sampling was undoubtedly biased, and your actual mileage may vary.</p>
<p>MATLAB struck me as being the wrong tool for every problem.  I was 
able to do just about everything I wanted, but laboriously.  Handling 
strings in MATLAB code was downright painful:  for example, IIRC, an 
array of strings must have all members the same length.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3817">
	<div class="div-comment" id="div-comment-3817">
<div id="comment-3817" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3817" title="comment permalink">#19</a></span>
		<span class="fn">billb</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/a9e257ca2ff9b3dd65ed1abe534fe05e.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>I dunno, “-fno-alias” on the command line, perhaps?</p>
<p>BTW, C++ compiler writing in C++ may make you an expert in the parts 
of C++ that are useful for , but it doesn’t make you and expert in 
numerically (floating-point/scientific) intensive C++ coding. But I 
didn’t really intend to question your bona fides. </p>
<p>My basic point was that you didn’t really get the best that the 
languages had to offer, but you did get some of the best that the 
languages had to offer to a few days (or weeks maybe) of optimization 
work. </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3818">
	<div class="div-comment" id="div-comment-3818">
<div id="comment-3818" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3818" title="comment permalink">#20</a></span>
		<span class="fn"><a href="http://scienceblogs.com/catdynamics" rel="external nofollow" class="url">Steinn Sigurdsson</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/af6a6855a2abcdbd44b4df6b8b324563.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>There is a well known way to write efficient C code for numerically intensive applications;<br>
write C wrappers to handle I/O and user interfacing, and have them call fortran subroutines…<br>
Works.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3819">
	<div class="div-comment" id="div-comment-3819">
<div id="comment-3819" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3819" title="comment permalink">#21</a></span>
		<span class="fn">weapon</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/0b9f6af2e8b60dfd7c937bfaa61277dc.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>&gt; for (int i=0; i &lt; 20000) {<br>
&gt;    for (int j=0; j &lt; 20000) {<br>
&gt;     x[i][j] = y[i-2][j+1] *<br>
&gt; y[i+1][j-2];<br>
&gt;  }<br>
&gt; }</p>
<p>I can’t see why the above code can’t be optimized wrt parallel 
computing. Now with global optimization, a good C++ compiler could 
easily figure out that whether x and y points to the same array, or 
whether they overlap. Doesn’t it?</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3820">
	<div class="div-comment" id="div-comment-3820">
<div id="comment-3820" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3820" title="comment permalink">#22</a></span>
		<span class="fn">KeithB</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/3e06e6943b3c48a3fe03adb079e15595.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>“How do you tell a C++ compiler that there’s no aliasing between two three dimensional arrays of floats?”</p>
<p>I don’t know about C++, but in C99 you have the “restrict” keyword:<br>
“…it serves as a ‘no alias’ hint to the C compiler.  This means that the
 pointer is, at the moment, the only way to access the object to which 
it points.”</p>
<p>This is from Harbison and Steele, 5th edition.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3821">
	<div class="div-comment" id="div-comment-3821">
<div id="comment-3821" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3821" title="comment permalink">#23</a></span>
		<span class="fn">billb</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/a9e257ca2ff9b3dd65ed1abe534fe05e.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Blake: That’s why MATLAB eventually got cell arrays (a kind of 
meta-array for those who don’t know MATLAB). MATLAB is a great language 
for prototyping small problems that involve linear algebra or fourier 
transforms where you don’t care to spend the time implementing these 
core routines yourself of call a more complicated library. In my 
experience anything outside of 1-D is best done somewhere else.</p>
<p>However, I still do all my line and scatter plotting in MATLAB. I’ve just gotten used to the way they look.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3822">
	<div class="div-comment" id="div-comment-3822">
<div id="comment-3822" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3822" title="comment permalink">#24</a></span>
		<span class="fn">Mark Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>billb:</p>
<p>-fnoalias isn’t the kind of thing I was talking about. That’s an 
assertion that you should *always* assume that things are independent 
unless you can prove that they aren’t (ie, the opposite of normal). The 
big problem with a lot of programming in C/C++ is that there are *some* 
loops where all of the values are independent; and there are some where 
*some* of the values are independent, and there are *some* where nothing
 is independent. In Fortran, you can often recognize which variables are
 definitely independent; in SISAL, you can always recognize which 
variables are definitely independent; in C/C++ it’s very hard to 
recognize which variables are independent.</p>
<p>In Fortran-98, there’s now support for pointers. But the way that 
they work, when you declare or allocate a value, you have to declare 
that it can be assigned in a way that produces aliases. There’s no 
equivalent for that in C/C++. (I know there was an attempt to get a 
“noalias” keywork into C++, but it failed.)</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3823">
	<div class="div-comment" id="div-comment-3823">
<div id="comment-3823" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3823" title="comment permalink">#25</a></span>
		<span class="fn"><a href="http://en.wikipedia.org/wiki/Astrochicken" rel="external nofollow" class="url">Astrochicken</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/f51aefad0c276c00256be826229cff4f.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Mark Chu-Carroll:</p>
<p>Did your OCaml implementation have problems with parallelism on an 
SMP machine? From what I read (and understand), OCaml does not allow 
multi-threading within the same process regarding accessing 
shared-memory. So, a numerical analysis algorithm written in OCaml might
 be limited to a single-processor machine if efficiency is desired.</p>
<p>Source:<br>
<a href="http://caml.inria.fr/pub/ml-archives/caml-list/2002/11/64c14acb90cb14bedb2cacb73338fb15.en.html" rel="nofollow">http://caml.inria.fr/pub/ml-archives/caml-list/2002/11/64c14acb90cb14bedb2cacb73338fb15.en.html</a></p>
<p>Sorry for the long URL.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3824">
	<div class="div-comment" id="div-comment-3824">
<div id="comment-3824" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3824" title="comment permalink">#26</a></span>
		<span class="fn">Mark Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>weapon:</p>
<p>Sometimes, it’s easy to recognize whether two arrays are distinct; sometimes it isn’t. If you’ve got code where the<br>
declarations are right there, then it’s easy. But there’s lots of code where it’s very hard to tell.</p>
<pre>   double a[325][17];
   double b[] = munge(a, x);
   double c[] = mungemore(b,a[13]);
   mungeb(b,a,c);
</pre>
<p>When you start to see code like there – where the arrays are getting 
passed around to lots of different functions, and some of the arrays are
 return values from functions, and those functions are called from 
multiple call points… Tractable global analysis just doesn’t hold up 
well. There’s just too much potential aliasing going on. </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3825">
	<div class="div-comment" id="div-comment-3825">
<div id="comment-3825" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3825" title="comment permalink">#27</a></span>
		<span class="fn"><a href="http://flexweb.asu.edu/" rel="external nofollow" class="url">Stephen Wells</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/ac315cffd52e1e14eeaf10ba57613845.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Your choice of language probably depends a lot on whether the most 
time-consuming part of the operation is the part that happens in the 
computer or the part that happens in your head, trying to a) implement 
your algorithm and b) understand what it did afterwards. I have 
simulation codes in C++ that could probably be made faster in Fortran, 
and parsers in Python that could probably be faster in C++, but in both 
cases it’s not the computer that’s the rate-determining step in my 
workflow, it’s me. Also if I want to write code so that someone else 
understands what it’s doing… I’ll trade a little speed for some clarity.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3826">
	<div class="div-comment" id="div-comment-3826">
<div id="comment-3826" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3826" title="comment permalink">#28</a></span>
		<span class="fn">Mark Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Astrochicken:</p>
<p>I have no idea how the code would have run on an SMP. The project was
 building a fast, lightweight SCM systems for developing software on 
workstations. So the tests were run on<br>
an IBM desktop PC. It’s long enough ago that I don’t recall which 
pentium generation it was, or what the processor clock speed was. But it
 was a single processor x86-family machine.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3827">
	<div class="div-comment" id="div-comment-3827">
<div id="comment-3827" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3827" title="comment permalink">#29</a></span>
		<span class="fn"><a href="http://en.wikipedia.org/wiki/Astrochicken" rel="external nofollow" class="url">Astrochicken</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/f51aefad0c276c00256be826229cff4f.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Mark Chu-Carroll:<br>
“But it was a single processor x86-family machine.”</p>
<p>That was your first mistake. But, that is a religious war for another thread.</p>
<p>Regarding SMP and OCaml, I think we can conclude that the hardware 
platform constrains the development language decision as much as the 
problem set.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3828">
	<div class="div-comment" id="div-comment-3828">
<div id="comment-3828" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3828" title="comment permalink">#30</a></span>
		<span class="fn">billb</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/a9e257ca2ff9b3dd65ed1abe534fe05e.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Mark, no one disagrees that there are aliasing problems in C/C++, 
but I think that you’d find that compilers have come a long way in the 
last 6 years. A very long way. So much so that I think you would 
reevaluate your claim that they are dreadful languages for writing 
scientific code in if you took another look.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3829">
	<div class="div-comment" id="div-comment-3829">
<div id="comment-3829" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3829" title="comment permalink">#31</a></span>
		<span class="fn">Mark Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Astrochicken:</p>
<p>The machine wasn’t my choice. In industry, we’re often constrained by
 all sorts of external realities – things like hardware and operating 
systems (and even programming languages) are often dictated by the 
requirements of whoever’s paying for the research.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3830">
	<div class="div-comment" id="div-comment-3830">
<div id="comment-3830" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3830" title="comment permalink">#32</a></span>
		<span class="fn">bigTom</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/7dcce837366fbada364caaca17f3da89.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>  Well, the de-facto aliasing rules in Fortran are convienient for 
optimizing compilers. Two parameters to a subroutine are de-facto 
assumed to be independent, so no fancy dependence checking algorithms 
are needed. Of course if you know enough of the ins and outs of a 
specific implementation of (say C), you can probably find ways to change
 the compilers aliasing (or other) assumption, either via compile line 
options, or pragmas.<br>
  The more serious problems in wringing performance out of systems has 
to do with the hidden, but very strongly non-uniform performance of 
memory. In general the languages aren’t designed to allow programmers to
 control things like bytes/words/cache-lines/ and memory pages, yet<br>
the hardware uses or abuses these constructs based upon the low level 
details, largely the sequence of memory addresses that comes from the 
program, and whether it makes efficient -or sometimes very inefficient 
usage of the hidden memory management layers of the hardware.<br>
  Especially if your goal is to use SSE/Altivec, whose instructions can 
handle multiple ops/instruction, things like address alignment<br>
with respect to natural memory boundaries, and/or the compilers ability 
to know if two arrays, have the same alignment wrt these boundaries can 
be crucial to its ability to exploit such features.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3831">
	<div class="div-comment" id="div-comment-3831">
<div id="comment-3831" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3831" title="comment permalink">#33</a></span>
		<span class="fn">jonmoore</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/8f99b9c8c3a97d8cb54e6d889f7db8e5.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>billb’s right about dealing with aliasing, although it obviously 
depends on the machine and compiler you’re using since it is outside the
 language spec.</p>
<p>For example, I used SGI’s C/C++ compilers back in the 90s and even then you had the choice of </p>
<p>(i) at the function level, declaring variables to be non-aliasing<br>
(ii) for individual loops, adding a pragma to say it was safe to parallelize</p>
<p>It’s a pain to have to do this, but it’s not such a pain as to rule out C/C++ for numerical programming, not by a long shot.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3832">
	<div class="div-comment" id="div-comment-3832">
<div id="comment-3832" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3832" title="comment permalink">#34</a></span>
		<span class="fn"><a href="http://brahms.phy.vanderbilt.edu/%7Erknop/blog" rel="external nofollow" class="url">Rob Knop</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/3b08c2afb7d0e1594c89e9e2d73b78ce.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p><i>But there’s no way to write code in C or C++ that guarantees that.</i></p>
<p>Sure there is — use the Standard Template Library, and use a vector or some such.</p>
<p>I have no clue if the compilers are smart enough to recognize that 
and do things that wouldn’t be safe to use with pure pointers, but in 
principle it could be done.</p>
<p>I program mostly in C++, and I *almost never* use pointers any more. 
 C++ still has its own quirks and problems, but the argument that “C++ 
is entirely a pointer-based language” is obselete in the face of the 
STL.</p>
<p>-Rob</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3833">
	<div class="div-comment" id="div-comment-3833">
<div id="comment-3833" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3833" title="comment permalink">#35</a></span>
		<span class="fn">Mark Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Rob:</p>
<p>The STL doesn’t get rid of pointers – it just disguises them. STL is 
implemented using pointers! And in fact, much of the STL code is some of
 the most hideous gorp that I’ve ever had the misfortune to have to 
read. Might be fine from a users perspective (although I don’t even like
 it from *that* point o view), but it’s a mess internally. Optimizing 
for alias elimination is *not* a reason to use STL. </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3834">
	<div class="div-comment" id="div-comment-3834">
<div id="comment-3834" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3834" title="comment permalink">#36</a></span>
		<span class="fn">Mark Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Gang:</p>
<p>Please try to remember that my point isn’t that C and C++ suck; it’s 
that the following statement from the linked article is *incorrect*:</p>
<blockquote><p>
First of all, these fears are nonsense. C and C++ are never going to 
disappear. Why? Because there are classes of programming problems that 
are still and will always be CPU bound and there is still no language as
 fast as C or C++ for these problems. I highly doubt that there ever 
will be.
</p></blockquote>
<p>My point is that not only is it not true that there is no language as
 fast as C and C++, but that there are languages that are often 
*faster*. The fallacy in the title of this post is that using C/C++ is 
*the only way* to write code if speed is your primary concern. </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3835">
	<div class="div-comment" id="div-comment-3835">
<div id="comment-3835" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3835" title="comment permalink">#37</a></span>
		<span class="fn">Simon</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/95b232dba741c82068d724637a477aba.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>For non-real time systems, how much a performance hit is ok?  If my
 app is 10% slower in language X than C++, but I can implement it twice 
as fast, then I get more time down the pub.   </p>
<p>I do quite a bit of simulation work, and have given up on fighting 
compilers and languages and avoiding stupid bugs arising from trying to 
do clever things. Its not worth the hassle. Although, I guess your 
mileage will vary.</p>
<p>For me, writing bug free code is very important. C++ (and similar 
languages) offer too many places to make mistakes.  In fiddly scientific
 computing this is a big issue. I wonder how many papers contain duff 
results because someone was accessing beyond array bounds in C?</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3836">
	<div class="div-comment" id="div-comment-3836">
<div id="comment-3836" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3836" title="comment permalink">#38</a></span>
		<span class="fn"><a href="http://h4ck3r.net/" rel="external nofollow" class="url">Scott</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/6814ce7ed15a31e3bf205999f0a39746.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Every C/C++ compiler that’s used by people who care about 
performance has a version of restrict, __restrict, or __restrict__. The 
aliasing argument is certainly true if you’ve never written performant 
code and don’t really know what you’re talking about, but otherwise it’s
 pretty bogus.</p>
<p>Second, you’ve got to be joking about OCaml. It’s capped at 25% of my
 current PCs CPU resources, and that doesn’t seem about to change, 
sadly: <a href="http://caml.inria.fr/pub/ml-archives/caml-list/2005/04/3fe33497071e1d9a065533d825ba848b.en.html" rel="nofollow">http://caml.inria.fr/pub/ml-archives/caml-list/2005/04/3fe33497071e1d9a065533d825ba848b.en.html</a></p>
<p>Distribution across multiple CPU resources will be the most important
 optimization consideration within 2-3 years, if it isn’t already.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3837">
	<div class="div-comment" id="div-comment-3837">
<div id="comment-3837" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3837" title="comment permalink">#39</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>cleek:</p>
<p>Sometimes rewriting a loop in a way that makes it faster is the wrong thing to do.</p>
<p>The example that I mentioned with OCaml is a good one. The original 
code had two separate loops; OCaml merged them and then extracted local 
constants.</p>
<p>Could I have done the same thing by hand in the C code? Yes. But it 
would have been a stupid thing to do. The code was ultimately going to 
be used as a part of a large complicated system. The algorithm was based
 on taking two passes over the input arrays. The results of the first 
pass are used as inputs to the second pass. Semantically, the two are 
*really* very different. </p>
<p>It happens that the compiler can figure out that on the n+1th 
iteration of loop one, you have enough information to run the nth 
iteration of loop two, provided you play a few tricks – which is what 
the compiler did.</p>
<p>If I were to write the code as the merged loop, it would make it 
significantly harder to understand, and significantly harder to debug if
 there were a problem.</p>
<p>In writing real code, that’s a common tradeoff. Even if the compiler 
*can’t* do that for you, swapping a 20% increase in execution time for a
 significant improvement in readability and maintainability is a *very* 
good exchange. There are even common cases where a 100% performance 
penalty is acceptable in exchange for better code clarity. (For example,
 in that prototype of Stellation, there were some parts of the code that
 were highly IO bound. Processing a line of input takes *much* less time
 – on the order of 1/100th the time – than *reading* a line of input. So
 making the code to process a line take twice as long in order to make 
what’s being done to it is fine, since the main effect of it is to 
reduce the amount of idle time the code spends waiting for the next line
 of input. </p>
<p>You don’t want to deliberately *waste* cycles. But if you’ve got a 
choice between writing comprehensible, maintainable code, and writing 
the most perfectly optimal fast code, often you want to pick the clean 
stuff.</p>
<p>So going back to that original loop example: merging the two passes 
into a single pass that plays pointer tricks would be a terrible thing 
to do. It would take the code from a very clear two-pass algorithm into a
 very hard-to-follow one-pass. </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3838">
	<div class="div-comment" id="div-comment-3838">
<div id="comment-3838" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3838" title="comment permalink">#40</a></span>
		<span class="fn">anupam</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/5522149b2f3ae587f43dac4b027e518a.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>wrt to aliasing why not just use the restrict keyword or some 
variant thereof that should do the trick. no ? also, i guess, compilers 
in general are conservative while doing code generation. it is _much_ 
better to have _slow_ but correct code, instead of fast but incorrect 
one. if you can nudge the compiler onto the right path, it should go a 
long way in improving code performance. but, when everthing is 
exhausted, you stil have assembly !</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3839">
	<div class="div-comment" id="div-comment-3839">
<div id="comment-3839" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3839" title="comment permalink">#41</a></span>
		<span class="fn">BMurray</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/ca679fbd4bcf7286d4cf6be5a43bbb9a.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Any optimizations your C compiler is incapable of identifying you can always rectify with some inline assembly code!</p>
<p>Seriously, there’s a reason we like compilers to optimize for us, and
 any C programmer should be well versed in what C can’t do for you 
rather than just assert anything can be done.  Of course anything can be
 done — you can inline assembler.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3840">
	<div class="div-comment" id="div-comment-3840">
<div id="comment-3840" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3840" title="comment permalink">#42</a></span>
		<span class="fn"><a href="http://cleek.lunarpages.com/blogs" rel="external nofollow" class="url">cleek</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/2e41d52b2986c0c63a2f464e34b7b3f3.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p><i>Sometimes rewriting a loop in a way that makes it faster is the wrong thing to do.</i></p>
<p>true. but only if speed is not your primary concern.</p>
<p>i write <a href="http://www.smalleranimals.com/" rel="nofollow">2D image processing software</a>
 professionally, and aside from correct results, speed is all my 
customers care about. they don’t care if i have to use MMX/SSE or twist 
the logic into knots, they just want it to run faster than my 
competitors. they regularly send me benchmarks of my stuff vs. Lead and 
Pegasus – if i’m slow, they’re unhappy. they don’t care if the code is 
unmaintainable – they’re not maintaining it, i am. so i do my best to 
keep it commented, so i’ll at least know <i>why</i> i did what i did.</p>
<p>clarity is great. at my day job, i primarily use C#, and i go out of 
my way to simplify and clarify. but speed’s not so high on the priority 
list, there. we can always buy a faster web server.</p>
<p>so… i agree, code clarity is important, but not always.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3841">
	<div class="div-comment" id="div-comment-3841">
<div id="comment-3841" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3841" title="comment permalink">#43</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>BMurray:</p>
<p>Actually, writing inline assembly code really isn’t a good thing on modern architectures. On modern architectures,<br>
making code run fast is incredibly hard – probably beyond the ability of
 almost any human being in a reasonable amount of time. You need to work
 out the memory access times, to figure out when to issue fetches and 
stores; you need to arrange instructions to keep the pipelines full 
without blocking, etc.  A few years ago, we just routinely said we could
 throw in some hand-optimized assembler when we needed to; that’s really
 not true anymore. Now, most hand-written assembler will be *worse* than
 what the compiler generates, because the compiler can optimize for for 
cache, pipeline, and memory and the tradeoffs between them.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3842">
	<div class="div-comment" id="div-comment-3842">
<div id="comment-3842" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3842" title="comment permalink">#44</a></span>
		<span class="fn">billb</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/a9e257ca2ff9b3dd65ed1abe534fe05e.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Mark, you’ve switched arguments. You declared C and C++ unusable 
for scientific purposes, but now you’re saying that we should simply 
consider other languages that might be slower or might be faster. What 
gives?</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3844">
	<div class="div-comment" id="div-comment-3844">
<div id="comment-3844" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3844" title="comment permalink">#45</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>billb:</p>
<p>I didn’t intend to switch arguments <img src="the-c-is-efficient-language-fallacy_files/icon_smile.gif" alt=":-)" class="wp-smiley">
 . I just went a bit overboard in how I stated it. I never intended my 
point to be that no scientific code should be written in C/C++; I was 
responding to the idea in the linked article that scientific/numeric 
code should *only* be written in C++, and that *nothing else* is *as 
fast* as C/C++, and that further nothing else *will ever be* as fast as 
C/C++. But in fact, not only is C/C++ always the fastest thing, but it’s
 often *not* the fastest, and there are numerous choices of languages 
that are at least as fast as C++.</p>
<p>Personally, *I* would *never* write scientific or numeric code in C 
or C++. But then, these days, I can’t think of much of anything that I 
would voluntarily write in C++. I still use C from time to time, and 
think it’s a very good language for low level OS-type code; I don’t 
think it’s a good choice for numeric/scientific. I’ve come to *despise* 
C++, and personally, I don’t think it’s suitable for much of anything. 
It’s a giant wretched pile of muck.</p>
<p>You *can* write scientific code in C or C++. But it’s a whole lot 
harder to make it run as fast as possible using a language like C/C++ 
than it is in a lot of other languages.<br>
It really is a lot easier to write most kinds of numeric/scientific code
 in Fortran than in C++, and it’s much easier for the compiler to 
generate optimal code for Fortran than for C/C++. Sisal routinely beat 
Fortran by 20%, and Fortran routinely beats C and C++. </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3845">
	<div class="div-comment" id="div-comment-3845">
<div id="comment-3845" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3845" title="comment permalink">#46</a></span>
		<span class="fn">billb</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/a9e257ca2ff9b3dd65ed1abe534fe05e.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Considering what can be done in C++, I’d say the level of muck 
(from negative muck to decidedly no muck to considerable muck) is up to 
the author. Of course, I’m getting ready to replace my input parser with
 embedded lua, so what do I know?</p>
<p>I’m not a C++ bigot by far, but I can make it do what I like, and it 
interfaces seamlessly with the C and POSIX standard libraries on the 
UNIX-like sytems I do all my work on (large clusters). Those two 
together make it hard for me to beat with anything else.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3846">
	<div class="div-comment" id="div-comment-3846">
<div id="comment-3846" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3846" title="comment permalink">#47</a></span>
		<span class="fn">Markk</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/ee11f041be26f1ab861e5729b0a84200.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>“Actually, writing inline assembly code really isn’t a good thing on modern architectures. On modern architectures,<br>
making code run fast is incredibly hard – probably beyond the ability of
 almost any human being in a reasonable amount of time. You need to work
 out the memory access times, to figure out when to issue fetches and 
stores; you need to arrange instructions to keep the pipelines full 
without blocking, etc”</p>
<p>This is true but not true – for small functional units, especially in
 constrained systems, we have never found the compiler better than hand 
doing it. The compiler is often good enough that it isn’t worth the 
effort, but once you get down to less than 50 “important” instruction 
units, people can iterate and get things as good or faster. You learn 
how many times you can unroll with a given workload, you can usually 
throw out some instructions, you really can do a better job than a 
compiler most of the time in getting superscalar order. There aren’t 
really that many ways to be out of order that matter, and cache is of 
course really of supreme importance – data cache mostly.</p>
<p>Of course the amount of code this matters for is almost zero really. 
If we had just dumped doing this I don’t know if anyone would really 
have noticed, ecept for not having hard limits,  but it did make the 
programmers aware of things. (This was a couple years ago, but nothing 
has changed much I hear.)</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3847">
	<div class="div-comment" id="div-comment-3847">
<div id="comment-3847" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3847" title="comment permalink">#48</a></span>
		<span class="fn">Alexei K</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/6c1f5ef56be0525ef0230542b103946e.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>for those interested, here is a bunch of straight forward (as in 
not part of huge projects) algorithms common in many fields of computer 
science, though you mustn’t take it as some absolute benchmark like 
3dmark is for example:</p>
<p><a href="http://shootout.alioth.debian.org/gp4sandbox/" rel="nofollow">http://shootout.alioth.debian.org/gp4sandbox/</a></p>
<p>this does at times show the superiority of non C languages, though in
 grand majority of cases, C family holds the crown of performance.</p>
<p>Though what I find interesting about that benchmark is the 
“alternative” implementation section (multiple implementation in the 
same laguage). I particularly like the example of alt algorithm in Lua 
taking about 80% less time than “naive” version. The trick was that for 
computing alternating sum it’s better to do 2 loops, one for plusses and
 one for minuses, and then subtract the results, than it is to do a one 
loop alternating summation. Though apparently that was interpreter’s 
fault and has been fixed now, but there are other (less dramatic in 
performance diff) examples there.</p>
<p>That’s the type of thing I love about that site.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3848">
	<div class="div-comment" id="div-comment-3848">
<div id="comment-3848" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3848" title="comment permalink">#49</a></span>
		<span class="fn"><a href="http://anjanb.wordpress.com/" rel="external nofollow" class="url">anjan bacchu</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/bea5dab764a7a4945d874b9fecfc1802.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>hi there,</p>
<p> nice post.</p>
<p>  “About a year later, testing a new JIT for Java, the Java time was 
down to 0.7 seconds to run the code, plus about 1 second for the JVM to 
start up.”</p>
<p>I’m wondering what type of hardware you had. Even now, a JVM on a 
Pentium 4 2.x GHz 2 GB RAM on windows xp, it takes more than a second 
for the JVM to load and give control to the main() method. </p>
<p>Also, it should be noted that the C startup times can be as big/small
 as you want. You can trim down the libraries that get initialized and 
called to what you really need in the application. For the hardware that
 was popular 6 years ago (say year 2000), the C startup time can be less
 than 0.1 second.</p>
<p>BR,<br>
~A</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3849">
	<div class="div-comment" id="div-comment-3849">
<div id="comment-3849" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3849" title="comment permalink">#50</a></span>
		<span class="fn">John</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/535f647310d047ab9980f0aa44a5254e.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Are there any languages out there that are designed to take 
advantage of SMP machines?  It would seem that would be awfully useful 
for scientific work.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3850">
	<div class="div-comment" id="div-comment-3850">
<div id="comment-3850" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3850" title="comment permalink">#51</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>anjan:</p>
<p>I don’t remember the exact model. It was the IBM distro of the  JVM 
(IBMs JIT was better than Suns), running under Linux on a single 
processor intel PC.</p>
<p>I’m surprised that you see such a slow startup for Java. My machine 
(a brand new MacBook Pro, Intel Core Duo 2Ghz) can run Java code much 
faster than that… Quick testing looks like it’s under 0.2 seconds to 
main. Hard to nail it down any more precisely than that.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3851">
	<div class="div-comment" id="div-comment-3851">
<div id="comment-3851" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3851" title="comment permalink">#52</a></span>
		<span class="fn">Derek</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d92fec932ad0ed6d55080fa1e0cbadb7.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>FWIW, here are some language benchmarks.</p>
<p><a href="http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&amp;lang=all" rel="nofollow">http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&amp;lang=all</a></p>
<p>C places first, OCaml places seventh, Java places 12th. </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3852">
	<div class="div-comment" id="div-comment-3852">
<div id="comment-3852" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3852" title="comment permalink">#53</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>John:</p>
<p>There are lots of languages that try to take advantage of SMP. A few 
examples are: Sisal, which I mentioned above, was designed for parallel 
processing, and did a great job. One of the design points in Fortran-98 
was to make it easy to write programs that could be compiled for various
 kinds of parallel machines, including SMP. SCL is a common lisp 
designed for scientific computing, and which has support for SMP. Lots 
of C/C++ compilers provide SMP support. </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3853">
	<div class="div-comment" id="div-comment-3853">
<div id="comment-3853" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3853" title="comment permalink">#54</a></span>
		<span class="fn">Koray</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/eb4199e3868f9c885ef653423538ed27.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Nice thread.</p>
<p>Even though it’s admittedly flawed, check out the Programming Languages Shootout (<a href="http://shootout.alioth.debian.org/" rel="nofollow">http://shootout.alioth.debian.org/</a>). If you dive deep, you can see some surprising results.</p>
<p>However, I must admit that C is still not necessarily slower than 
anything else given manually inserted aliasing pragmas, profile based 
branching optimizations, CPU manufacturer provided compilers, etc.</p>
<p>Fortunately, only a tiny percentage use C like that. I bet most people don’t even care enough to set the CPU arch flags right.</p>
<p>However, a lot of people do care about things like threading and 
multiprocessing to get performance. C can be in serious trouble here.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3854">
	<div class="div-comment" id="div-comment-3854">
<div id="comment-3854" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3854" title="comment permalink">#55</a></span>
		<span class="fn">Alexei K</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/6c1f5ef56be0525ef0230542b103946e.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>@John: that’s why we have the all mighty MPI and its lesser 
brethren (by lesser, I’m talking about my opinion of them, not their 
theoretical ability). Languages as such don’t really have parrallelism 
built in in any way I’d call serious, but some are made receptive to 
integration with other API, of which MPI is one. (you might be more 
familiar with Thread like api’s that most languages have built in, but I
 don’t like that programming paradigm and would never code using it)</p>
<p>@Derek: owned ya there by 26 min <img src="the-c-is-efficient-language-fallacy_files/icon_smile.gif" alt=":)" class="wp-smiley"> </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3855">
	<div class="div-comment" id="div-comment-3855">
<div id="comment-3855" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3855" title="comment permalink">#56</a></span>
		<span class="fn">BC</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/c9edf70098f8c270a022a29f0a2c876f.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<blockquote><p>You *can* write scientific code in C or C++. But it’s a
 whole lot harder to make it run as fast as possible using a language 
like C/C++ than it is in a lot of other languages.</p></blockquote>
<p>Wha?  There’s plenty of evidence that C/C++ runs quickly in a lot of different situations.  In fact, you yourself state:<br>
    * C: 0.8 seconds.<br>
    * C++: 2.3 seconds.<br>
    * OCaml: 0.6 seconds interpreted, 0.3 seconds fully compiled.<br>
    * Java: 1 minute 20 seconds.<br>
    * Python: over 5 minutes.</p>
<p>In this list, C/C++ aren’t the fastest, but they’re a whole lot 
better than some other languages on the list.  Derek’s link says the 
same thing: <a href="http://shootout.alioth.debian.org/gp4/benchmark.php?test=all%E2%8C%A9=all" rel="nofollow">http://shootout.alioth.debian.org/gp4/benchmark.php?test=all〈=all</a></p>
<p>Further, you’re making a mistake by saying that because C/C++ handles parallelism bad, it’s all-around bad.</p>
<blockquote><p>I’ve come to *despise* C++, and personally, I don’t think
 it’s suitable for much of anything. It’s a giant wretched pile of muck.</p></blockquote>
<p>And you’re showing that you’re a language snob with that statement.  
All you’re doing is trying to justify your own personal preferences by 
trying to find situations where C/C++ does badly and acting like it’s 
all-around bad.</p>
<p>BTW, I’ve seen C++ code which is optimized for different CPUs, and 
setup to take advantage of the parallel processing inherent in those 
CPUs – you can get a big speed boost out of that kind of code.  You’re 
making the same mistake that so many other people make: you don’t 
understand the language well enough or don’t want to write the opimized 
routines, and then complain that the language is just inherently 
inferior, justifying your own preconceived ideas.  There are lots of 
ways to judge languages (ease of use, personal preferences, ability to 
create programs quickly, speed, memory usage, etc), and even I don’t 
like all programming languages, but I’m not going to construct some bad 
argument about why you shouldn’t use language X, that I happen dislike.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3856">
	<div class="div-comment" id="div-comment-3856">
<div id="comment-3856" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3856" title="comment permalink">#57</a></span>
		<span class="fn">billb</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/a9e257ca2ff9b3dd65ed1abe534fe05e.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>SMP ain’t enough parallelism.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3857">
	<div class="div-comment" id="div-comment-3857">
<div id="comment-3857" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3857" title="comment permalink">#58</a></span>
		<span class="fn">Alexei K</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/6c1f5ef56be0525ef0230542b103946e.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>This is totally random, but I’d like to point out that there was a 
game for Playstation 2 (can’t remember the title, but it was one of the 
major blockbasters of the time) that was written *entirely* in Scheme, 
but it was some sort of compiled version of Scheme that actually 
produced assembler code for PS2.</p>
<p>I don’t really mean this as a proof of anything, just thought it was a
 nice thing, and it made me for the first time consider that perhaps C 
family isn’t the be-all-end-all of programming.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3858">
	<div class="div-comment" id="div-comment-3858">
<div id="comment-3858" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3858" title="comment permalink">#59</a></span>
		<span class="fn"><a href="http://los.alamos.com/" rel="external nofollow" class="url">los alamos</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/a4c209e48dc9aca9a2b479ee6c527fb2.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>comments about stl efficiency are a little too hasty, imho.</p>
<p>have you seen blitz++?<br>
<a href="http://www.oonumerics.org/blitz/" rel="nofollow">http://www.oonumerics.org/blitz/</a></p>
<p>also see <a href="http://www.oonumerics.org/" rel="nofollow">http://www.oonumerics.org</a> and <a href="http://acts.nersc.gov/pooma/" rel="nofollow">http://acts.nersc.gov/pooma/</a></p>
<p>“”"Blitz++ is a C++ class library for scientific computing which 
provides performance on par with Fortran 77/90. It uses template 
techniques to achieve high performance. The current versions provide 
dense arrays and vectors, random number generators, and small vectors 
and matrices.”"”</p>
<p>“”" Goals of the Blitz++ library</p>
<p>The C++ programming language offers many features useful for tackling
 complex scientific computing problems: inheritance, polymorphism, 
generic programming, and operator overloading are some of the most 
important. Unfortunately, these advanced features came with a hefty 
performance pricetag: until recently, C++ lagged behind Fortran’s 
performance by anywhere from 20% to a factor of ten. As a result, the 
adoption of C++ for scientific computing has been slow.</p>
<p>Is there a way to soup up C++ so that we can keep the advanced 
language features but ditch the poor performance? This is the goal of 
the Blitz++ project: to develop techniques which will enable C++ to 
rival — and in some cases even exceed — the speed of Fortran for 
numerical computing, while preserving an object-oriented interface. The 
Blitz++ Numerical Library is being constructed as a testbed for these 
techniques.</p>
<p>Recent benchmarks show C++ encroaching steadily on Fortran’s 
high-performance monopoly, and for some benchmarks, C++ is even faster 
than Fortran! These results are being obtained not through better 
optimizing compilers, preprocessors, or language extensions, but through
 the use of template techniques. By using templates cleverly, 
optimizations such as loop fusion, unrolling, tiling, and algorithm 
specialization can be performed automatically at compile time.</p>
<p>Another goal of Blitz++ is to extend the conventional dense array 
model to incorporate new and useful features. Some examples of such 
extensions are flexible storage formats, tensor notation and index 
placeholders. “”"</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3859">
	<div class="div-comment" id="div-comment-3859">
<div id="comment-3859" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3859" title="comment permalink">#60</a></span>
		<span class="fn"><a href="http://los.alamos.com/" rel="external nofollow" class="url">los alamos</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/a4c209e48dc9aca9a2b479ee6c527fb2.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>comments about stl efficiency are a little too hasty, imho.</p>
<p>have you seen blitz++?<br>
<a href="http://www.oonumerics.org/blitz/" rel="nofollow">http://www.oonumerics.org/blitz/</a></p>
<p>also see <a href="http://www.oonumerics.org/" rel="nofollow">http://www.oonumerics.org</a> and <a href="http://acts.nersc.gov/pooma/" rel="nofollow">http://acts.nersc.gov/pooma/</a></p>
<p>“”"Blitz++ is a C++ class library for scientific computing which 
provides performance on par with Fortran 77/90. It uses template 
techniques to achieve high performance. The current versions provide 
dense arrays and vectors, random number generators, and small vectors 
and matrices.”"”</p>
<p>“”" Goals of the Blitz++ library</p>
<p>The C++ programming language offers many features useful for tackling
 complex scientific computing problems: inheritance, polymorphism, 
generic programming, and operator overloading are some of the most 
important. Unfortunately, these advanced features came with a hefty 
performance pricetag: until recently, C++ lagged behind Fortran’s 
performance by anywhere from 20% to a factor of ten. As a result, the 
adoption of C++ for scientific computing has been slow.</p>
<p>Is there a way to soup up C++ so that we can keep the advanced 
language features but ditch the poor performance? This is the goal of 
the Blitz++ project: to develop techniques which will enable C++ to 
rival — and in some cases even exceed — the speed of Fortran for 
numerical computing, while preserving an object-oriented interface. The 
Blitz++ Numerical Library is being constructed as a testbed for these 
techniques.</p>
<p>Recent benchmarks show C++ encroaching steadily on Fortran’s 
high-performance monopoly, and for some benchmarks, C++ is even faster 
than Fortran! These results are being obtained not through better 
optimizing compilers, preprocessors, or language extensions, but through
 the use of template techniques. By using templates cleverly, 
optimizations such as loop fusion, unrolling, tiling, and algorithm 
specialization can be performed automatically at compile time.</p>
<p>Another goal of Blitz++ is to extend the conventional dense array 
model to incorporate new and useful features. Some examples of such 
extensions are flexible storage formats, tensor notation and index 
placeholders. “”"</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3860">
	<div class="div-comment" id="div-comment-3860">
<div id="comment-3860" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3860" title="comment permalink">#61</a></span>
		<span class="fn"><a href="http://los.alamos.com/" rel="external nofollow" class="url">los alamos</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/a4c209e48dc9aca9a2b479ee6c527fb2.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>comments about stl efficiency are a little too hasty, imho.</p>
<p>have you seen blitz++?<br>
<a href="http://www.oonumerics.org/blitz/" rel="nofollow">http://www.oonumerics.org/blitz/</a></p>
<p>also see <a href="http://www.oonumerics.org/" rel="nofollow">http://www.oonumerics.org</a> and <a href="http://acts.nersc.gov/pooma/" rel="nofollow">http://acts.nersc.gov/pooma/</a></p>
<p>“”"Blitz++ is a C++ class library for scientific computing which 
provides performance on par with Fortran 77/90. It uses template 
techniques to achieve high performance. The current versions provide 
dense arrays and vectors, random number generators, and small vectors 
and matrices.”"”</p>
<p>“”" Goals of the Blitz++ library</p>
<p>The C++ programming language offers many features useful for tackling
 complex scientific computing problems: inheritance, polymorphism, 
generic programming, and operator overloading are some of the most 
important. Unfortunately, these advanced features came with a hefty 
performance pricetag: until recently, C++ lagged behind Fortran’s 
performance by anywhere from 20% to a factor of ten. As a result, the 
adoption of C++ for scientific computing has been slow.</p>
<p>Is there a way to soup up C++ so that we can keep the advanced 
language features but ditch the poor performance? This is the goal of 
the Blitz++ project: to develop techniques which will enable C++ to 
rival — and in some cases even exceed — the speed of Fortran for 
numerical computing, while preserving an object-oriented interface. The 
Blitz++ Numerical Library is being constructed as a testbed for these 
techniques.</p>
<p>Recent benchmarks show C++ encroaching steadily on Fortran’s 
high-performance monopoly, and for some benchmarks, C++ is even faster 
than Fortran! These results are being obtained not through better 
optimizing compilers, preprocessors, or language extensions, but through
 the use of template techniques. By using templates cleverly, 
optimizations such as loop fusion, unrolling, tiling, and algorithm 
specialization can be performed automatically at compile time.</p>
<p>Another goal of Blitz++ is to extend the conventional dense array 
model to incorporate new and useful features. Some examples of such 
extensions are flexible storage formats, tensor notation and index 
placeholders. “”"</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3861">
	<div class="div-comment" id="div-comment-3861">
<div id="comment-3861" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3861" title="comment permalink">#62</a></span>
		<span class="fn">KeithB</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/3e06e6943b3c48a3fe03adb079e15595.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>MarkCC wrote:<br>
“The example that I mentioned with OCaml is a good one. The original 
code had two separate loops; OCaml merged them and then extracted local 
constants.</p>
<p>Could I have done the same thing by hand in the C code? Yes. But it 
would have been a stupid thing to do. The code was ultimately going to 
be used as a part of a large complicated system. The algorithm was based
 on taking two passes over the input arrays. The results of the first 
pass are used as inputs to the second pass. Semantically, the two are 
*really* very different. ”</p>
<p>Is their any reason why this is unique to OCaml?  Couldn’t *any* compiler do the same thing?  </p>
<p>If this thread keeps going are you going to make C/C++ Friday’s Pathological Language?<br>
8^)</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3862">
	<div class="div-comment" id="div-comment-3862">
<div id="comment-3862" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3862" title="comment permalink">#63</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>KeithB:</p>
<p>Lots of compilers *could* do something like what the OCaml did; the 
key is whether or not it can determine enough information about the 
semantics of the program to be certain that the transformation is valid.
 </p>
<p>Most functional language compilers would do the equivalent 
transformation. I’m pretty sure that most of the really good CommonLisp 
compilers would; Sisal *definitely* did that kind of transformation 
(Sisal was designed specifically to make transformations like that 
easy); SML/NJ *might*.</p>
<p>I know that some Java JITs do that kind of transformation  on a 
dynamic basis; the information to ensure its validity isn’t there in a 
form that can be easily detected statically in Java, but the JIT gets to
 use dynamic information as well, and most JITs can recognize a loop as a
 hot spot in the code, analyze and generate specialized code with a very
 fast dynamic independence check.</p>
<p>Pretty much *every* high performance fortran compiler would do the 
equivalent transformation; most Fortran code would be tractable to 
recognize the validity.</p>
<p>I won’t go so far as to say that no C++ compiler does it, but it’s 
*very* hard to get enough static information about multidimensional 
arrays in C++ to be able to do something like that safely. </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3863">
	<div class="div-comment" id="div-comment-3863">
<div id="comment-3863" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3863" title="comment permalink">#64</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>And WRT the question about whether I’d make C++ the weeks 
pathological language… In general, I don’t consider C++ to be 
particularly pathological. Poorly designed? Yes. Pathological? No.</p>
<p>(The reason I said “in general” is because the template system in C++
 can get pretty damned pathological. The C++ template system is, I 
*think*, Turing complete. I know for certain that it’s at least 
primitive recursive. One of the tests that I saw a member of the C++ 
compiler team write was a program that made the compiler compute a 
factorial *at compile time*. Templates are very close to being a 
functional programming language of a particularly bizarre sort.)</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3864">
	<div class="div-comment" id="div-comment-3864">
<div id="comment-3864" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3864" title="comment permalink">#65</a></span>
		<span class="fn"><a href="http://danvk.org/" rel="external nofollow" class="url">Dan Vanderkam</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/a2aaa6cd108f9a803ec61e20d76963f1.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>There’s nothing stopping the compiler from writing two versions of 
the function, a slow version for the aliased case and a fast, parallel 
version for the more common case. Or simpler, just throw a giant if 
statement around the whole function:</p>
<p><code>
</code></p><pre><code>if (overlap(x,y)) {
  // ... slow ...
} else {
  //... fast, parallel ...
}</code></pre><code>
</code><p><code></code></p>
<p>If there are 20,000*20,000 iterations, then this optimization would be well worth it.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3865">
	<div class="div-comment" id="div-comment-3865">
<div id="comment-3865" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3865" title="comment permalink">#66</a></span>
		<span class="fn">JJS</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/2b9a28f046c43c51ebd73fa6dd3cdc7c.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Erwin Unruh showed in 1994 (in connection with the ANSI C++ 
commitee) that you could use C++ templates to compute an arbitrary 
number of primes at compile time, and output them as compiler error 
messages.</p>
<p>More recently, Todd Veldhuizen produced something more direct, showing how to embed Turing machines as template instantiations.</p>
<p>As to your comment about templates being close to a bizarre 
functional programming language, it only takes a couple of lines of 
template code to produce a template providing the typical functional way
 of calculating factorials — at compile time.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3866">
	<div class="div-comment" id="div-comment-3866">
<div id="comment-3866" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3866" title="comment permalink">#67</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>JJS: </p>
<p>Thanks for the pointer. I didn’t know about Veldhuizen; his paper is a
 piece of diabolical genius. For anyone who’s interested, here’s the URL
 for a paper showing how to build a Turing machine using C++ templates, 
so that the compiler needs to run the TM simulation to compile the 
program!</p>
<p><a href="http://osl.iu.edu/%7Etveldhui/papers/2003/turing.pdf" rel="nofollow">http://osl.iu.edu/~tveldhui/papers/2003/turing.pdf</a></p>
<p>Brilliant!</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3867">
	<div class="div-comment" id="div-comment-3867">
<div id="comment-3867" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3867" title="comment permalink">#68</a></span>
		<span class="fn">Pseudonym</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/3352d7b7b661c84c5b888312397efc76.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>My pet peeve is lumping C and C++ into the same basket.  C++ is at 
its most horrid when it’s programmed like you would program in C.</p>
<p>In the case of numeric programming, for example, C++ has some very 
nice BLAS bindings these days, like Boost.uBLAS.  And unlike C or 
Fortran, they’re even nice to use, because you can use the addition and 
multiplication operators instead of having to remember what SAXPY means.</p>
<p>Incidentally, try writing the LCSS algorithm in Haskell some time.  
Dynamic programming in Haskell is really, REALLY elegant.  You set up a 
data structure full of unevaluated thunks which depend on other thunks, 
then just evaluate the element you want.  Lazy evaluation takes care of 
the rest.</p>
<p>You can even do this with <a href="http://www.haskell.org/hawiki/MemoisingCafs" rel="nofollow">infinite</a> data structures.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3868">
	<div class="div-comment" id="div-comment-3868">
<div id="comment-3868" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3868" title="comment permalink">#69</a></span>
		<span class="fn"><a href="http://brainwagon.org/" rel="external nofollow" class="url">Mark VandeWettering</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/cfed2ce72949006be3f124f9bb12f3de.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>I must admit, I’ve been programming professionally for over twenty 
years now, and most of that in C, although I’ve done a fair amount of 
Common Lisp (none lately), C++, Python and a smattering of other 
languages.  I’ve now settled into a fairly consistent mix of C and 
Python.</p>
<p>While I understand the point that you are making quite clearly, I 
think that you exaggerate the degree to which it really matters.  Even 
in your example, C was only about a factor of two off the time for 
compiled OCaml, whereas both C and OCaml were hundreds of times faster 
than interpreted Java and Python.   While there are certainly downsides 
to using C (and even more in using C++ if you ask me), C compilers 
(courtesy of gcc) are virtually ubiquitous, and compilers like icc from 
Intel do even better at code optimization.   </p>
<p>As programmers, it is part of our duty to pick appropriate tools for 
appropriate jobs.  It simply isn’t as idiotic to pick C for numerical 
codes as you make it out to be, and other considerations might actually 
make it a reasonable choice.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3869">
	<div class="div-comment" id="div-comment-3869">
<div id="comment-3869" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3869" title="comment permalink">#70</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Pseudonym:</p>
<p>In Fortran-98, it does array arithmetic using the arithmetic 
operators. F’98 also has operator overloading, etc. It’s got pretty much
 everything that’s good about C++ combined with everything that was 
*already* good about Fortran. It’s actually a surprisingly nice 
language.</p>
<p>I would actually love to try something like LCS in Haskell. I’ve 
really been wanting to do some more coding in Haskell; of the languages I
 know, it’s the one that I’m fascinated by that I’ve gotten to use the 
least. LCS is the kind of thing that would be great to try, because it’s
 something that you’d write *so* differently in Haskell compared to the 
other languages I use frequently. </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3871">
	<div class="div-comment" id="div-comment-3871">
<div id="comment-3871" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3871" title="comment permalink">#71</a></span>
		<span class="fn">Ravi</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/97b909d2b4a3414ef11f7b6af02f9895.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>C, C++ may be fast, but they are difficult to code large programs 
in. Don’t bring all that REAL PROGRAMMERS USE “X” LANGUAGE shit.<br>
 I am a selfish  programmer. Just as everybody  wants to have a shiny OS
 or a shiny app that lets them do more, I like a shiny high level 
language, that lets me do more in the time I can spend. If it does not 
run fast enough, dude …. , it will, sometime in the future. And guess 
what, my code would be far more readable than the one written in C/C++ 
then. You see, the all your futures are belong to high-level languages <img src="the-c-is-efficient-language-fallacy_files/icon_biggrin.gif" alt=":D" class="wp-smiley"> .</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3872">
	<div class="div-comment" id="div-comment-3872">
<div id="comment-3872" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3872" title="comment permalink">#72</a></span>
		<span class="fn"><a href="http://rufnkiddingme.blogspot.com/" rel="external nofollow" class="url">jayinbmore</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d1291eead75e52ba078e075636ab8040.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Mark,</p>
<p>Not to get too cute, but your own numbers demonstrate that there’s a 
general purpose C program out there which outperforms your hand tuned C 
program in that particular task. It’s called the OCaml interpreter. </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3873">
	<div class="div-comment" id="div-comment-3873">
<div id="comment-3873" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3873" title="comment permalink">#73</a></span>
		<span class="fn">Przemek Klosowski</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/ee1341fd46709393752068a160c2c4b8.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Some people here pooh-poohed specialized languages like 
Octave/Matlab, which is really . If the main computation in the code is 
doing some special-purpose operation, like linear algebra along the 
lines of BLAS, it is naive to expect to do better than the tailored 
low-level code that the special-purpose language will dive into. There 
is an amazing amount of work put by the likes of Kazuhiro Goto or<br>
the ATLAS group into optimizing their BLAS speed. They took care of 
esoteric things like minimizing cache and TLB misses, which I fully 
expect to be botched by mere mortals in  their attempts to reimplement 
it in C/C++/Fortran.</p>
<p>A case in point: Octave, which is a Matlab functional equivalent, is 
not known for top interpreter speed, When doing straight numerics on 
large arrays, however, it smokes, simply because it just jumps into 
optimized low-level BLAS or FFTW or other library code. Even if one used
 such low level libs from C/C++ rather than rewriting them, one would 
still have to consistently use it in a best possible way.</p>
<p>This discussion reminds me of another debate going on in the embedded
 computing/microcontroller area, on relative merits of assembler vs. HLL
 programming. It is true that top assembler coders beat compilers on 
selected pieces of code: they spend effort on finding non-obvious code 
tricks and shortcuts, etc. etc. At the same time, the compilers 
consistently plow along, generating better code than an average coder, 
and even beating top assembly programmers on bodies of code that are too
 large for humans to comprehend in detail required for 
superoptimization.</p>
<p>As a bonus assignment, look up the GNU superoptimizer: a program that combinatorially goes through finite sequences<br>
of machine instructions, trying to find shorter expressions of simple algorithms–exactly the kind of magic that top<br>
assembly programmers were famous for, except that the superoptimizer never gets tired or distracted.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3876">
	<div class="div-comment" id="div-comment-3876">
<div id="comment-3876" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3876" title="comment permalink">#74</a></span>
		<span class="fn"><a href="http://www.mudge.nl/" rel="external nofollow" class="url">tomvandijck</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d66ee6610e30bcf478f496f9cb9185d9.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>“This is totally random, but I’d like to point out that there was a
 game for Playstation 2 (can’t remember the title, but it was one of the
 major blockbasters of the time) that was written *entirely* in Scheme, 
but it was some sort of compiled version of Scheme that actually 
produced assembler code for PS2.”</p>
<p>If I recall correctly that was Ratchet and Clank.<br>
But that had not much to do with performance, although they did a very 
good job on the compiler.. I think this was chosen mostly because it was
 easier to define gameplay constructs in that language.</p>
<p>In that same area I did a full 1.5 compliant Java Virtual machine for
 the PS2 and Xbox, just to make it easier to write games, without having
 to relink the game.. giving gameplay programmers a faster turnaround 
time, and a better tool to debug their games. In the final product we 
would just ‘pre-jit’ all code into a binairy form anyway.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3877">
	<div class="div-comment" id="div-comment-3877">
<div id="comment-3877" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3877" title="comment permalink">#75</a></span>
		<span class="fn">Charlie</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/a278c47a0752ecef1ab339c6ed816e5e.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>“This is totally random, but I’d like to point out that there was a
 game for Playstation 2 (can’t remember the title, but it was one of the
 major blockbasters of the time) that was written *entirely* in Scheme, 
but it was some sort of compiled version of Scheme that actually 
produced assembler code for PS2.”</p>
<p>You’re probably thinking of Jak &amp; Daxter, which was written in a 
Lisp-like (the syntax was Lispy, and it had macros, but it didn’t have 
closures or garbage collection) called <a href="http://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp" rel="nofollow nofollow nofollow">GOAL.</a></p>
<p>Naughty Dog got great performance from GOAL for a couple reasons: 
one, it offered every assembly instruction as an intrinsic, with very 
nice Lispy syntax. (ADD R1,R2,R3 becomes (add r1 r2 r3).) So there were 
great swathes of code written in what amounted to 
assembly-language-with-variables. Second, it had runtime code 
replacement – you could make a change and see the results in about half a
 second.</p>
<p>That meant that the graphics guys could tune the code *very* finely. 
They’d pull up a bunch of performance metrics, and fiddle with the game 
while it was running. (“How about if I swap these two instructions – 
faster or slower? OK, how about these two…”) This is, of course, only 
reasonable because the code ran on the Playstation 2, and *no other* 
hardware. Every processor it would ever run on would be identical.</p>
<p>There’s also a secondary argument that the productivity advantages of
 Lisp/Scheme macros meant that the programmers had more time to optimize
 performance-critical parts of the code.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3878">
	<div class="div-comment" id="div-comment-3878">
<div id="comment-3878" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3878" title="comment permalink">#76</a></span>
		<span class="fn">Charlie</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/a278c47a0752ecef1ab339c6ed816e5e.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>“If I recall correctly that was Ratchet and Clank.”</p>
<p>Ratchet and Clank was written in C++, although they had access to the
 Jak &amp; Daxter codebase in GOAL. (Insomniac and Naughty Dog, the two 
companies in question, used to be in the same building and still have a 
close relationship.) I don’t know to what extent they used the Jak/Dax 
assembly in their engine.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3879">
	<div class="div-comment" id="div-comment-3879">
<div id="comment-3879" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3879" title="comment permalink">#77</a></span>
		<span class="fn">T C</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d95ab4b35ca641e0e667f05a8b53842c.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Excellent article. But it’s wrong to call the original statement a 
“fallacy”. It’s a “falsehood”. Those two things are not the same! <img src="the-c-is-efficient-language-fallacy_files/icon_smile.gif" alt=":-)" class="wp-smiley"> </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3880">
	<div class="div-comment" id="div-comment-3880">
<div id="comment-3880" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3880" title="comment permalink">#78</a></span>
		<span class="fn">jd</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/9a6ce51fcfecc681a6e9fb063920af31.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 2, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>By far, the most important factor in any algorithm’s performance 
for any language is the skill of the programmer implementing it. The 
primary reason people say C is always going to be the fastest is that 
almost every other “higher-level” language is implemented in C. Ergo, if
 language X can do something in Tx time, and X is implemented in C, then
 C can do the same task in Tx time. It is pretty hard to get around that
 logic. All you can do is look for another language that compiles 
directly to assembly. Then, the same argument about the speed of 
assembly applies. True, you may need an expert in C or Assembly to get 
the best speed possible. But given that all code is eventually 
implemented in (probably) C and (definitely) Assembly, we must conclude 
that Assembly is, indeed, the fastest language. The reason there are 
other language is because we don’t all want to have to be experts in C 
and/or Assembly. But if you want optimum speed, with no other 
consideration, the only logical choice is C and/or Assembly coded by an 
expert.</p>
<p>PS – Take another look at the earlier comment that says, in effect, 
you are fastest in your favorite language. That person knows what they 
are talking about. I have similar anecdotal evidence myself for this. A 
few years ago, some Java person claimed that Java was, in fact the 
fastest language and posted the code. Of course, the C++ code was awful.
 I re-wrote the C++ using modern templates and easily beat the Java 
code. Not only that, the C++ code in question also beat the C code 
(written by the Java guy). This particular example was complex matrix 
math. The C code used lots of pointers. My C++ code used the STL and 
looked, on the surface, relatively inefficient. However, the C++ 
compiler is made for C++ after all, and it made my code very, very fast.
 Again, not much evidence for my example, but just as much evidence as 
you have provided:)</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3882">
	<div class="div-comment" id="div-comment-3882">
<div id="comment-3882" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3882" title="comment permalink">#79</a></span>
		<span class="fn">penguinpusher</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d78e637ee99c5405fab30ac9aeca2f8b.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Umm before claiming C++ sucks rocks for numerics you should really find out how people use it for numerics. In particular <a href="http://osl.iu.edu/%7Etveldhui/papers/Expression-Templates/exprtmpl.html" rel="nofollow">expression templates</a> which solve the exact problem you complaining about.</p>
<p>You may find this enlightening too <a href="http://gamearchitect.net/Articles/WhyC++.html" rel="nofollow">http://gamearchitect.net/Articles/WhyC++.html</a>
 a little quote is “It’s easy to hire people who call themselves C++ 
programmers, but engineers who understand both the low-level details of 
the C++ object model and the compile-time power of C++ template 
metaprogramming are hard to come by. And C++, in the hands of an 
programmer without a good grasp of the language, is a dangerous thing.”</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3884">
	<div class="div-comment" id="div-comment-3884">
<div id="comment-3884" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3884" title="comment permalink">#80</a></span>
		<span class="fn">Anonym</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/a30e08b346d8876a4dccdc8ebc3cea2c.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Very interesting discussion. On the C++ side you can take a look at
 Blitz++. On the Python side there is Psyco, that if used well can 
reduce your running time to 1 minute or less. Shedskin is a Python 
compiler that often can reach C++ speeds.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3885">
	<div class="div-comment" id="div-comment-3885">
<div id="comment-3885" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3885" title="comment permalink">#81</a></span>
		<span class="fn"><a href="http://t-a-w.blogspot.com/" rel="external nofollow" class="url">Tomasz Wegrzanowski</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/98e5e1f8fb2da8322a032e3ff2d7e668.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>I’m the first to agree that C/C++ suck, but it’s rather unfair to use gcc for any performance comparison. <a href="http://openlab-mu-internal.web.cern.ch/openlab-mu-internal/Documents/3_Presentations/Slides/2006/35-AH_spec_presentation_ols.pdf" rel="nofollow">gcc is horribly slow compared to other C/C++ compilers like icc</a>.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3886">
	<div class="div-comment" id="div-comment-3886">
<div id="comment-3886" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3886" title="comment permalink">#82</a></span>
		<span class="fn"><a href="http://cgranade.blogspot.com/" rel="external nofollow" class="url">Christopher Granade</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/b586b12f39dda2b560b3857c5e5f6892.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>I would prefer specialized languages like MATLAB were it not for 
some of the coding style things which give me grief; specifically, the 
lack of explicit variable typing and declaration annoys me in MATLAB. 
There’s no doubt that the parallelizing and vectorizing features of 
MATLAB are superb, but C/C++ could relatively easily be extended to 
support that, thus giving both a more structured programming approach 
and the absurdly powerful vectorizing techniques of MATLAB. To some 
degree, GPU-only languages like Brook and Cg do this to accommodate the 
massively parallel structure of modern GPUs. With hyper-threading, 
multi-core processing and vector registers, I see it being only a matter
 of time before languages like C/C++ are forced to either adapt to 
vectorization or fall by the wayside.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3887">
	<div class="div-comment" id="div-comment-3887">
<div id="comment-3887" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3887" title="comment permalink">#83</a></span>
		<span class="fn">Lambda Llama</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/b019bcf7520475e1df8ab39ecd5d7edf.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Interesting that you mention Lisp. Usually, I find that Lisp is 
about 2/3 as fast as C, but is well worth using for scientific 
programming because 1) fewer lines are needed 2) the selectable safety 
level lets you catch array and other bugs 3) it is interactive, 
bypassing much of the tedious edit-compile-run-debug cycle, and allowing
 easier subunit testing 4) it simplifies much of the high-level data 
bookkeeping (lists, hashes) that consumes much of ones time. Absolute 
CPU time is not the only consideration when discussing speed. The real 
question is “how long does it take you to get the right answer?”</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3888">
	<div class="div-comment" id="div-comment-3888">
<div id="comment-3888" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3888" title="comment permalink">#84</a></span>
		<span class="fn">chris</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/3e8ca2f4ca610dbac95bb853b6ccb72c.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<pre><code>for (int i=0; i &lt; 20000) {
   for (int j=0; j &lt; 20000) {
      x[i][j] = y[i-2][j+1] * y[i+1][j-2];
   }
}
</code></pre>
<p>I don't think it matters what language you write an infinite loop in.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3889">
	<div class="div-comment" id="div-comment-3889">
<div id="comment-3889" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3889" title="comment permalink">#85</a></span>
		<span class="fn">Ben St. John</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/a9f3806b2b0867f7d5c242b1348838d1.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Excellent comments in general. Mark, I’ll agree with your general 
point that aliasing is a problem (but not an insurmountable one) in 
C/C++, and that sometimes other languages can do a better job. However, I
 think for many performance-intensive tasks, C/C++ is the best offering 
out there, when you balance a number of factors out. (Speed of naive 
implementation, ease of finding programmings, portability, 
interoperability, maturity of tool set, optimization possibilities 
(including in-line assembly))</p>
<p>Obviously Fortran is also a contender, although my impression is that
 it’s more that its primary benefits are the existing libraries, and 
arrays.</p>
<p>A few minor points though: there is a significant difference between<br>
int x[100]<br>
and<br>
int * x;<br>
just take the ‘sizeof’ both, for example; one is 400 (usually!) the 
other, 4. So the compiler has some idea what’s going on. As others have 
noted with keywords, annotations, and compiler flags, you can generally 
get to where you want. You can even (via pragmas) often do nice things 
like cache pre-fetches, or cache-line alignment.</p>
<p>Regarding how complex writing assembly is, I would say your argument 
really only applies to Intel x86. Maybe AMD too, I’m not sure. For other
 systems (I’ve used MIPS R3000, 68k, and TI DSPs) hand-coded assembly 
was consistently better. It’s partly dependent on how complex the chip 
is, partly on how mature the compiler/tool chain is. Intel x86 is 
extreme by both measures.</p>
<p>Finally, regarding GOAL, (1) it was only for the animation system of 
Jak &amp; Daxter, (2) it had inline assembly, (3) after Naughty Dog was 
bought, in the next version of the game the animation system was 
re-written *without* GOAL, although apparently more because of 
infrastructure/programmer issues than language issues. So it’s not 
really a poster child for non-C efficient coding. The main advantage 
they cited was being able to change things on-the-fly. The wikipedia 
article is not the best, but has good links.</p>
<p>I’m not against other languages — C++ is beginning to feel like a 
monster to me too. But I still think it’s the best tool for many tasks.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3891">
	<div class="div-comment" id="div-comment-3891">
<div id="comment-3891" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3891" title="comment permalink">#86</a></span>
		<span class="fn"><a href="http://emmanueloga.blogspot.com/" rel="external nofollow" class="url">Emmanuel</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/b3086d7340aeba221e30ce8679eab3f3.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>I presume you know the computer language shutout. Please, see for yourself:</p>
<p><a href="http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&amp;lang=g95&amp;lang2=gpp" rel="nofollow">http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&amp;lang=g95&amp;lang2=gpp</a></p>
<p>I’m not an expert on computer languages, but c++ seems to be the 
fastest language in almost all of the benchmarks. Take note that you 
cannot judge the performance of a language based on a single benchmark.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3892">
	<div class="div-comment" id="div-comment-3892">
<div id="comment-3892" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3892" title="comment permalink">#87</a></span>
		<span class="fn">AndyC</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/e5e9767281f738540609fa547e41aab0.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>An oft overlooked point in this area is that the people writing all
 this numerically intensive code are not necessarily hardcore 
programmers. It’s often scientists and grad students who just want to 
get the right results as quickly as possible. Expecting them to hand 
tune C/C++ or make the best use of compiler switches is somewhat 
unrealistic. Any language which allows the naive case to produce 
something closer to the optimum code has to be a good thing.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3893">
	<div class="div-comment" id="div-comment-3893">
<div id="comment-3893" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3893" title="comment permalink">#88</a></span>
		<span class="fn">Wouter Lievens</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/abbddf7434a6982f4790032a8b99aaad.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Not really. Numerically intensive code isn’t just academic. Just think about the chips inside your digital video recorder.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3894">
	<div class="div-comment" id="div-comment-3894">
<div id="comment-3894" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3894" title="comment permalink">#89</a></span>
		<span class="fn">zhaphod</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/e5f4a5106b4597ce3ccafa2fc46c7005.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>I found the following very interesting link while doing some 
research on how to learn OCaml {because some of the comments mentioned 
that it kicks ass when it comes to performance}. The link provides the 
bench marking results for various languages.</p>
<p><a href="http://shootout.alioth.debian.org/gp4/" rel="nofollow">http://shootout.alioth.debian.org/gp4/</a></p>
<p>I found that C {gcc implementation is invariably faster than all other languages}</p>
<p>Cheers</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3895">
	<div class="div-comment" id="div-comment-3895">
<div id="comment-3895" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3895" title="comment permalink">#90</a></span>
		<span class="fn">Jake Ham</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/8e4390c4f24f97164e32ccbf1a5e7072.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>This post has got way out of wack.  I don’t know if people aren’t 
reading his post, or understand his points.  People become defensive if 
you start taking jabs at their favorite language.</p>
<p>The point of the post is that there are alternatives!  Sometimes 
C/C++ will be faster, and sometimes it won’t, but if you don’t ever try 
your application in a different language you will never find out. </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3896">
	<div class="div-comment" id="div-comment-3896">
<div id="comment-3896" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3896" title="comment permalink">#91</a></span>
		<span class="fn"><a href="http://snews.bnl.gov/popsci/contents.html" rel="external nofollow" class="url">Blake Stacey</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/dd50e8b0462cc7fb7fa5bb0785e4f2a4.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>All technical issues aside, I think MarkCC should be proud of this 
one:  ninety comments and a place on the “most e-mailed” sidebar!  And 
all without mentioning string theory or Richard Dawkins.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3897">
	<div class="div-comment" id="div-comment-3897">
<div id="comment-3897" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3897" title="comment permalink">#92</a></span>
		<span class="fn">zhaphod</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/e5f4a5106b4597ce3ccafa2fc46c7005.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Follow up to link on shoot out at debian {http://shootout.alioth.debian.org/gp4/}:</p>
<p>I should say, according to the shootout at debian, C {gcc} is faster than many but not all. My mistake.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3898">
	<div class="div-comment" id="div-comment-3898">
<div id="comment-3898" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3898" title="comment permalink">#93</a></span>
		<span class="fn"><a href="http://www.perl.org/" rel="external nofollow" class="url">WarEagleBob</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/df3d6a7486554ca740d55a4a3289b894.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>While interesting, your post is comparing apples and oranges by 
saying a functional language is better than a proceedural language for 
your LCS problem.  If you want to bitch about a particular language 
compared to another, you should do it fairly.  Show a what languages are
 best at different classes of problems.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3899">
	<div class="div-comment" id="div-comment-3899">
<div id="comment-3899" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3899" title="comment permalink">#94</a></span>
		<span class="fn">Flaky</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/372959c3d2ca68d8c558447e39de5565.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>One of the main uses of C and C++ is system programming as they are
 seen as being fairly low-level. It certainly is the case, that the 
ability to directly manipulate pointers is necessary for interacting 
with the hardware. As for the other features of those languages, I see 
no particular reason, why a language with higher-level features and a 
more orthogonal feature set couldn’t be used for the same purpose. (BTW,
 Lack of orthogonality is my main grievance with C++. C++ is not a 
complex language because of its abundance of features, but because its 
features are interdependent in ways that requires you to be constantly 
aware of several features that might interplay in any piece of code you 
are currently writing.)</p>
<p>Is someone here aware of any language suitable for low-level system 
programming that would be aligned more to the functional paradigm?<br>
Such a language could have function closures, (mostly) immutable values 
(save for pointers and references of course), optional GC (with 
static+stack allocation as an alternative (requiring some way for the 
compiler to compute the maximum memory usage, of course)), pattern 
matching, and all of this (and more) packaged with strict typing for 
ease of development and optimisation by the compiler.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3900">
	<div class="div-comment" id="div-comment-3900">
<div id="comment-3900" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3900" title="comment permalink">#95</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>WarEagleBob:</p>
<blockquote><p>
While interesting, your post is comparing apples and oranges by saying a
 functional language is better than a proceedural language for your LCS 
problem. If you want to bitch about a particular language compared to 
another, you should do it fairly. Show a what languages are best at 
different classes of problems.
</p></blockquote>
<p>No, that’s not what this post is saying. </p>
<p>My main point was that C/C++ is *not* always the best, fastest 
language. The example was just that – an example, which demonstrated a 
computationally intensive numerical array-based algorithm for which I 
happened to have performance numbers for carefully implemented versions 
in several different languages. It’s the *same algorithm* in each of the
 languages; and the C++ version was the original(at the time, C++ is the
 language that I was most comfortable with); the implementations in the 
other languages were as close to the C++ version as I could reasonably 
make them.</p>
<p>The OCaml variant was *not* particularly functional. The functional 
nature of OCaml had *nothing* to do with the way that it performed 
better. It’s an array iteration algorithm, which is something that all 
of the languages happen similarly; and OCaml arrays are *not* 
functional; array slots are fully assignable just like in any of the 
other languages I tested. </p>
<p>OCaml just happened to have an incredible compiler and runtime which were able to infer and make use of static<br>
properties of the code to optimize it and run it without much overhead. </p>
<p>Later versions of my system were written in Java, and the Java 
performance got to the point of matching C, but it never quite made it 
to OCaml level. But with Java, there was a huge startup cost (which 
didn’t really hurt us, since our system was a long-running server; 5 
seconds at startup is fine for a system that’s going be invoked 1000 
times spread over a couple of days.). With OCaml,  I got peak 
performance for the algorithm, and with low overhead. It was *really* 
impressive.</p>
<p>I’m not trying to make the argument that everyone should rush out and
 start writing all of their scientific/numerical code in OCaml; it 
certainly wouldn’t be *my* first choice. (I’d probably pick one of the 
better CommonLisp’s out there; SBCL seems pretty damned fast.)  In 
particular, as someone pointed out earlier in the thread, the OCaml 
system doesn’t take advantage of multicore processor, which really sucks
 for serious scientific computation. My whole argument is that the claim
 that “C/C++ is the fastest, and always will be” is a stupid claim.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3901">
	<div class="div-comment" id="div-comment-3901">
<div id="comment-3901" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3901" title="comment permalink">#96</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Flaky:</p>
<p>I don’t know of any functional languages that I would really consider
 a good choice for really low-level programming. The closest thing to 
really functional that I’ve seen used for down-to-the-metal programming 
of things like operating systems and device drivers is a Lisp variant. </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3905">
	<div class="div-comment" id="div-comment-3905">
<div id="comment-3905" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3905" title="comment permalink">#97</a></span>
		<span class="fn">Michael Chermside</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/3c2ce5e843cef58cf546b403c6233597.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Thank you… wonderful article.</p>
<p>I am slowly coming around to the belief that higher-level languages 
will eventually be FASTER than low-level languages. The trouble with 
low-level languages is that you’re allowing the programmer to specify 
some of what the compiler does for the high-level language. As time goes
 by, compilers get smarter (and programmers get dumber<sup>1</sup>) so 
eventually the higher-level language will win. As you point out, the 
increasing difficulty of optimization just accelerates the trend, and 
the move toward fancy tricks like JIT is really putting on the pressure.</p>
<p>—-<br>
<sup>1</sup> – “as time goes by, programmers get dumber”: I know that *I* do anyhow.<sup>2</sup><br>
<sup>2</sup> – At least I can say that there’s more I *don’t* know about programming than there was when I was a beginner.<sup>3</sup><br>
<sup>3</sup> – Curiously, this makes me a better programmer.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3906">
	<div class="div-comment" id="div-comment-3906">
<div id="comment-3906" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3906" title="comment permalink">#98</a></span>
		<span class="fn">Xanthir, FCD</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/37881c0540fb86ebfa6c855e61021527.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Taking the tangent about Naughty Dog further…</p>
<p>I actually read an article by these guys.  It was, in fact, <strong>Crash Bandicoot</strong>
 that they used Lisp on.  Basically, they were *really* pushing the 
limits with that game in terms of what the PS1 could handle, and so 
optimizing it became too complex for a human.  Instead, they wrote an AI
 controller that rewrote code, rearranged data organization on the disc,
 and optimized memory calls so that they could just worry about writing 
the game instead of tweaking it endlessly to get it to perform well with
 seamless loads and such.</p>
<p>Apparently, they leaned on it even more with the later Crash games.  They were all pretty good, so I’m impressed.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3916">
	<div class="div-comment" id="div-comment-3916">
<div id="comment-3916" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3916" title="comment permalink">#99</a></span>
		<span class="fn">Memet</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/432a080cf00e1adb3b47f778c2f1ceb9.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p> I’m going to just add something on the whole billb &amp; Mark thread of conversation. For everyone’s sake I’ll be succinct.<br>
 Foreword: I like C++. I use it often. But I’m not a fanatic either. Also use LISP, VB, js…</p>
<p>Re C++: sure you can’t prove correctness etc in C++ because there are
 huge loopholes which can be exploited in the language (like 
reinterpret_casts).  But C\C++ *is* close to the metal, and so what 
certain compilers may lack in brightness, the C\C++ programmer can make 
up for in ingenious ways.<br>
 Does this mean C++ is faster “out of the box”? No. But then again, I 
can write you a program that will make a Java app leak memory.<br>
 So should we use C++ in enterprise scale applications because it’s just
 inherently faster? Probably not. Does this mean we shouldn’t use it in 
enterprise level applications? Not really either: unlike what most 
people think, the biggest thing C++ has got going for itself is not 
speed,  it’s templates. The kind of templates that only LISP based 
languages trump. Java don’t got templates, and I don’t think OO 
programming languages like OCaml do either (but maybe I’m mistaken). And
 I’m talking advanced templates (cf. ATL, STL).<br>
 And final word: C and C++ are as far apart as 286 and 386. C is 
basically a high level assembler. C++ is a very rich language with 
incredible compile time mechanisms (such as templates) hidden right 
under the surface.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3917">
	<div class="div-comment" id="div-comment-3917">
<div id="comment-3917" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3917" title="comment permalink">#100</a></span>
		<span class="fn">Xanthir, FCD</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/37881c0540fb86ebfa6c855e61021527.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 3, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<blockquote><p>The kind of templates that only LISP based languages 
trump. Java don’t got templates, and I don’t think OO programming 
languages like OCaml do either (but maybe I’m mistaken). And I’m talking
 advanced templates (cf. ATL, STL).<br>
And final word: C and C++ are as far apart as 286 and 386. C is 
basically a high level assembler. C++ is a very rich language with 
incredible compile time mechanisms (such as templates) hidden right 
under the surface.</p></blockquote>
<p>Must… resist… urge to pimp Lisp…</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3919">
	<div class="div-comment" id="div-comment-3919">
<div id="comment-3919" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3919" title="comment permalink">#101</a></span>
		<span class="fn">dave</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/c4e7e7ee129e9ff4ecdd9a7c4c892efa.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 4, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>It seems to me that the real fallacy that Mark is addressing is the
 assumption that being closer to the machine makes code run faster.  If 
what you need done is fiddling bits and chasing pointers in particular 
ways, then a language like C or C++ is going to give you fast code 
because it lets you say exactly what you mean (and your C code will 
probably be almost as fast as, and (if you do it right) far more 
portable than, writing it directly in assembly).<br>
The problem with the “C is fast because it’s close to the machine” 
argument is that there is a large (and growing) class of problems with 
solutions that are made easier to optimize by moving *farther away* from
 the machine, into a higher-level language that gives the compiler more 
information and/or lets it make more assumptions about what’s really 
going on, and lets the optimizer work its magic based on that instead of
 making the programmer do all the work.  Lower-level languages can 
sometimes make some of this up with (specialized, usually non-portable, 
often hard to get right) hints to the compiler, but they’re starting so 
far behind that it’s usually not worth the effort.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3927">
	<div class="div-comment" id="div-comment-3927">
<div id="comment-3927" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3927" title="comment permalink">#102</a></span>
		<span class="fn"><a href="http://www.pacifict.com/ron" rel="external nofollow" class="url">Ron Avitzur</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/437d8f653a7c00828a0397ccc948234d.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 4, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>While on the topic of efficency, let me emphasize a concern, though
 orthogonal to this discussion, which is sometimes overlooked at high 
cost: with main memory access speeds lagging ever behind CPU speeds, the
 difference between a calculation which fits entirely in on-chip cache 
and one which saturates the main memory bus may incur more than 100x 
performance penalty on the “same” algorithm and code.  The typical 
example is to benchmark a calculation with a nested loop over an array 
to see the performance difference of changing the order of nesting. One 
of the reasons matrix libraries are so fast is that they use block 
algorithms whenever possible to operate of portions which fit in the 
on-chip cache.  This issue becomes more complicated on multiprocessor 
systems where each CPU core has its own cache, possibly shared with 
other cores on the same chip, maybe not.  This is both a low-level 
detail of the system architecture, but also directly influences the 
design of high level algorithms to maximize locality of reference.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3928">
	<div class="div-comment" id="div-comment-3928">
<div id="comment-3928" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3928" title="comment permalink">#103</a></span>
		<span class="fn">Xerxes1729</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/b55dfeb0d4e73887e2a48dbb54f83698.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 4, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>As a mathematician with limited programming skills, I actually like
 Mathematica quite a bit.  I know it’s not the most efficient system out
 there, but I find that it’s easy to use for solving mathematical 
problems.  Also. it’s awfully nice to have a huge library of built-in 
functions and tools for things like solving NDEs.  If you’re not doing 
applied math, Mathematica is much more useful than MATLAB because of 
it’s ability to handle symbolic computations.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3930">
	<div class="div-comment" id="div-comment-3930">
<div id="comment-3930" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3930" title="comment permalink">#104</a></span>
		<span class="fn">Gaurav</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/392b55ab06fb53be5736f362d46092b4.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 4, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Bilb: </p>
<p>You said SMP isn’t enough parallelism. Could you expand on this a little bit? </p>
<p>Also, isn’t this something towards which chip vendors are making a push with their multi-core stuff? Any takes on that? </p>
<p>Thanks.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3931">
	<div class="div-comment" id="div-comment-3931">
<div id="comment-3931" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3931" title="comment permalink">#105</a></span>
		<span class="fn"><a href="http://www.centeredwork.com/" rel="external nofollow" class="url">AndyS</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/2da60d27036a055bd572cd2d222807e2.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 4, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Boy!  I sure enjoy a passionate programming language discussion.  
For some people _any_ criticism of their favorite language is like 
telling them their child is ugly.  </p>
<p>(This is a great thread.  I learned a lot.  Thanks to everyone.)</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3932">
	<div class="div-comment" id="div-comment-3932">
<div id="comment-3932" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3932" title="comment permalink">#106</a></span>
		<span class="fn">Alexei K</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/6c1f5ef56be0525ef0230542b103946e.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 5, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>@AndyS: the problem is that this article isn’t _any_ criticism, but
 a fundamental acusation of utter failure of a language in an entire 
field of algorithms. Which is nonsense, and rests on very few very weak 
examples. Such argument only needs few examples of other languages 
failing to other flaws to counteract, and that has been done (link to 
that benchmark site).</p>
<p>This article started out as a rant and should’ve been left as such, 
but the fact that Mark tried to defend it just made him look exactly 
like Granville Sewell whome Mark criticized last month in his post.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3934">
	<div class="div-comment" id="div-comment-3934">
<div id="comment-3934" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3934" title="comment permalink">#107</a></span>
		<span class="fn">Xanthir, FCD</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/37881c0540fb86ebfa6c855e61021527.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 5, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Alexei:</p>
<p>Did you *read* the post?  Mostly, Mark just criticized the other 
blog’s assertion that C is the fastest language and will always be.  He 
held that up with some examples of where other languages can perform 
better than C (taken from a period when he was programming extensively 
*in* C).</p>
<p>He goes further when he says that C sucks for numerical computing, 
and that can be challenged.  But he admitted that he may have gone too 
far there.  His main point, though, still stands – any assertion that “C
 is always going to be the fastest language” is false, and will get more
 and more false as time goes on.  Playing close to the machine is simply
 too difficult on modern, single-core machines.  Multi-cores will make 
the whole thing even more complex, and  the situation can only continue 
to deteriorate.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3936">
	<div class="div-comment" id="div-comment-3936">
<div id="comment-3936" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3936" title="comment permalink">#108</a></span>
		<span class="fn"><a href="http://mg.b4net.lt/" rel="external nofollow" class="url">Marius Gedminas</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/9381c7f1185e9c17527fccef45bdc09c.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 5, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Um, I’m pretty sure LCS of *two* arrays requires O(n<sup>2</sup>) time, not O(n<sup>3</sup>).</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3937">
	<div class="div-comment" id="div-comment-3937">
<div id="comment-3937" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3937" title="comment permalink">#109</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 5, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Marius:</p>
<p>No, sorry, the classic algorithm for LCS is n<sup>3</sup>. I’m not 
sure if that’s a proven lower bound, but the major algorithms for 
computing it are all variations on dynamic programming, and have an 
upper bound of <b>O</b>(n<sup>3</sup>).</p>
<p>The confusion is probably because “subsequence” doesn’t quite mean what most people think seeing the term. </p>
<p>Suppose we’ve got two sequences:</p>
<p>    [1, 3, 6, 9, 10, 11, 12, 14, 18, 19, 21, 22, 23]</p>
<p>and</p>
<p>    [2, 4, 6, 8, 10, 11, 12, 14, 16, 18, 20, 22]</p>
<p>Most people’s intuition on hearing the term “longest common 
subsequence” is that the LCS of those two would be [10, 11, 12, 14]. But
 in fact, the LCS is [6, 10, 11, 12, 14, 18, 22]. A subsequence is an 
arbitrary subset of the values in a sequence, which occur in the same 
order in the subsequence as they do in the original sequence. </p>
<p>If the elements of the list always appear in sorted order, like those
 two lists above, then it’s easy. But the classic LCS problem allows 
arbitrary re-orderings. So, for example,<br>
taking the LCS of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] and<br>
[2, 6, 3, 4, 8, 7, 10, 9].  The answer is that there are two equally 
long longest subsequences:  [2, 3, 4, 8, 9] and [2, 3, 4, 8, 10]. </p>
<p>Now, think about computing that on a two arrays of 10,000 values. 
(Stellation was an SCM system which attempted to be smarter than typical
 line-based systems; so a source file that was 1000 lines long could 
easily balloon into a list of 50,000 tokens; and we wanted the LCS of 
the two file versions. We reduced the tokens into numeric hashcodes for 
computing the LCS. If the idea had come out looking promising, we would 
probably have taken something like Wegman’s perfect hash function 
generator to prevent collisions, but it never got that far; the sub-line
 based diff computation is just too expensive in terms of memory to be 
tractable. Just think about two arrays of 10,000 elements each, and an 
algorithm which uses *on average* n lg n space, but can use up to n<sup>2</sup>
 space. If if you only use one byte per compared line-pair, that means 
that you could wind up eating 100 megabytes on the comparison table! And
 every trick we could come up for partitioning, merging, etc., to reduce
 the comparison table size couldn’t make word/token based diff 
computation manageable in general.)</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3938">
	<div class="div-comment" id="div-comment-3938">
<div id="comment-3938" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3938" title="comment permalink">#110</a></span>
		<span class="fn"><a href="http://george.sudarkoff.com/" rel="external nofollow" class="url">George Sudarkoff</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/0f9afa99528cbae28c6b6093fa5d0ebf.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 5, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Mark, I am sure you know that OCaml itself is implemented in C… I 
understand what you’re trying to say, but you should try harder.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3940">
	<div class="div-comment" id="div-comment-3940">
<div id="comment-3940" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3940" title="comment permalink">#111</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 5, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>George:</p>
<p>(1) OCaml is implemented in OCaml. It’s got its own native code 
generator. The only C code is interfaces to system routines. Ocaml came 
about because of a brilliant coder (I think it was Xavier Leroix) who 
was working with the CaML group at INRIA, and thought the regular CaML 
compiler was too big, so he implemented a small one, which he called 
Caml-Light. CaML light was implemented in the subset of CaML that it was
 designed to compile, and was bootstrapped. Since then, it’s been 
continually developed using itself. CaML light eventually replaced the 
old heavyweight CaML compiler, and Xavier et al extended it until it 
became the OCaml of today. Damn shame that they don’t seem to be doing 
anything to take advantage of the parallelism in modern systems.</p>
<p>(2) Even if Ocaml were implemented in C, it doesn’t really change my 
point. Suppose you have a task, T, and you’ve got a choice between two 
languages, language A and language B. In language A, you can write an 
algorithm in a clear and simple form which the compiler can optimize 
into an incredibly efficient executable; and in language B, you can get 
the same speed, but you need to go through all sorts of contortions to 
try to force the compiler to ultimately generate the fast code.  My 
argument is that for the problem domain of T, A is well-suited to the 
task, and B is not. </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3942">
	<div class="div-comment" id="div-comment-3942">
<div id="comment-3942" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3942" title="comment permalink">#112</a></span>
		<span class="fn">billb</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/a9e257ca2ff9b3dd65ed1abe534fe05e.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 5, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Gaurav: My work involves distributed memory parallelism (clusters 
and other supercomputers). There are some PGAS language extensions out 
there (UPC, Co-array Fortan, Fortess, X10, etc.) that give some old 
languages the ability to have a global address space across the memory 
on these machines, but they don’t take advantage of the inherent 
parallelism that the languages mentioned above might. That’s what I 
meant by SMP not being enough.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3943">
	<div class="div-comment" id="div-comment-3943">
<div id="comment-3943" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3943" title="comment permalink">#113</a></span>
		<span class="fn">Nicky Mclean</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/fa506747c25355e48ee0789a6b39a257.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 5, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>   It wasn’t until I encountered C and its derivatives that PL/I 
was raised in my estimation, which took some doing. Avoiding a rant at 
C’s inane syntax, I would merely point out that a simple mistype 
(adding, omitting or mistyping a single symbol) easily produces a 
syntactically correct source file. If say thirty minutes a week are lost
 in tracking down one such mistake, will it likely ever be recouped in 
any supposed faster-running of a C-source code file? Why else have one 
programmer typing and a second one watching for miscodes and mistypes?<br>
   It is ridiculous to assert that some programming language is always 
the best for all possible purposes. Even assembler, delivering the 
maximum possible performance (for the specific task on its specific 
system), the only possible candidate for this acclaim, is unsuitable 
because the programming costs are so high as to make its use 
unproductive except in very special cases. Why else do we use 
higher-level languages? Even if C is an elaborated assembler. And yes, I
 have written a multi-precision calculation of e, and pi, in assembler 
and not.<br>
   Fortran was designed from the start for number crunching, and it 
excels at this function. Its first implementation also considered 
complex array indexing optimisation, too error-prone to be done by hand 
when writing assembler. This was to counter one criticism from assembler
 programmers. Computer science types tend to mess about with text and 
complex data structures; they create languages for doing this 
expediently. Number crunchers from the science community want many large
 arrays and massive arithmetic, as found in Fortran. Just look at the 
silly syntax for arrays in C, and the obsolete idea of fixed lower 
bounds for arrays.<br>
   When dealing with statements such as X = A + B (all being arrays) 
there is no excuse for the compiler not generating good code for this, 
as distinct from having to write something like<br>
    for i:=1:N do<br>
     for j:=1:M do<br>
      x(i,j):=A(i,j) + B(i,j);<br>
     next j;<br>
    next i;<br>
   (I’m not going to besmirch the page with C’s redundant gibberish) 
which is not just more tedious and error-prone to type (array bounds? 
transposed index variables? plain mistypes with so much to type?) but 
also presumes that accessing the arrays rowwise (varying the second 
index to run along the columns of row i) is better than column-wise. 
With the statement of intent, X = A + B, the compiler would be free to 
implement it in any manner expedient. Rowwise, columnwise, in chunks of 
eight (or 16, or…) at a time: whatever, similarly the array indexing and
 iteration control would be its own. Possibly a comprehensive 
optimisation analysis would convert the explicit loops to such code, and
 probably, not.</p>
<p>   Comparison between computer languages is made more difficult by a 
modern trend, the provision of a compiler for language X by in fact 
providing a transliteration from X to C, and then compiling the C stuff 
that results. It seems unlikely that features not found in C (amazement!
 puzzlement!! incomprehension!!!) would result in code that improved on 
that which would be produced by a compiler explicitly recognising them 
and their meaning, rather than just their transliteration.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3944">
	<div class="div-comment" id="div-comment-3944">
<div id="comment-3944" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3944" title="comment permalink">#114</a></span>
		<span class="fn"><a href="http://george.sudarkoff.com/" rel="external nofollow" class="url">George Sudarkoff</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/0f9afa99528cbae28c6b6093fa5d0ebf.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 5, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Mark:</p>
<p>There you go! Thank you.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3946">
	<div class="div-comment" id="div-comment-3946">
<div id="comment-3946" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3946" title="comment permalink">#115</a></span>
		<span class="fn"><a href="http://notes.dpdx.net/" rel="external nofollow" class="url">Brooks Moses</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/4eb07a3c66dc527a51d08d8cb8291553.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 5, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>One minor correction: There isn’t any such thing as “Fortran 98″.  I presume you’re meaning to refer to Fortran 95?</p>
<p>(Well, I suppose it’s possible that you’re implying Fortran 95 plus 
the little bit of Fortran 2003 that allows allocable object components, 
which is a pretty common “standard” to write to, and could humorously be
 called “Fortran 98″ or somesuch — though I’ve never seen anyone do so!)</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3950">
	<div class="div-comment" id="div-comment-3950">
<div id="comment-3950" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3950" title="comment permalink">#116</a></span>
		<span class="fn"><a href="http://odalet.wordpress.com/" rel="external nofollow" class="url">Olivier</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/84b83058bc6f6bf7a2d9a998c3a63854.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 6, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>dileffante:</p>
<p>Nothing to do with the main subject, just precisions about<br>
Managed C++: this language is able to compile targetting .NET CLR 
(Microsoft VM) and to do so benefits from new syntax. But it is also 
fully (or 99%) compatible with previous versions of MS C++. So, Visual 
C++ Express should compile (to native code) your old VC++ 6 programs. 
The projects should even be opened and converted by the new IDE. MFC and
 ATL are supported.</p>
<p>Well, my experience is based on using the commercial version (Visual 
Studio 2005). But I suppose this should also be true for VC++ Express. 
It’s definitely not an obligation to convert your code to the managed 
flavour of C++. And the resulting binary will be pure native Windows 
code.</p>
<p>In fact this new language (MC++) is able to mix in a single binary native and managed code…</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3951">
	<div class="div-comment" id="div-comment-3951">
<div id="comment-3951" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3951" title="comment permalink">#117</a></span>
		<span class="fn">JY</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/bc5dc31fbe03779306df2ee52fb22c09.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 6, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Mark,</p>
<p>I think it’s the case that the calculation of the <em>length</em> of the LCS is O(n<sup>2</sup>), but the calculation of the LCS itself is O(n<sup>3</sup>).  In any event, here is the alg. for the <em>length</em> in Haskell, which is clearly O(n<sup>2</sup>).</p>
<p>
import Array</p>
<p>calccell a0 a1 mat (row,col) = </p>
<p>&nbsp;&nbsp;let (_, (rmax,cmax)) = bounds mat in<br>
&nbsp;&nbsp;&nbsp;&nbsp;if row == rmax || col == cmax then mat //[((row, col),0)]<br>
&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (a0!row) == (a1!col) then mat //[((row, col),(1 + (mat ! (row+1,col+1) ) ) )]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else mat // [((row,col),(max (mat!(row+1,col)) (mat!(row,col+1))))]</p>
<p>lcs as bs = <br>
&nbsp;&nbsp;let rows = length as<br>
&nbsp;&nbsp;&nbsp;&nbsp;cols = length bs<br>
&nbsp;&nbsp;&nbsp;&nbsp;aArr = listArray (0, rows) as<br>
&nbsp;&nbsp;&nbsp;&nbsp;bArr = listArray (0, cols) bs <br>
&nbsp;&nbsp;&nbsp;&nbsp;mat = array ((0,0),(rows,cols)) [] in<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(foldl (calccell aArr bArr) mat (reverse $ indices mat)) ! (0,0)</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3952">
	<div class="div-comment" id="div-comment-3952">
<div id="comment-3952" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3952" title="comment permalink">#118</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 6, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>JY:</p>
<p>That could be the source of the confusion. I’ve never looked for the 
*length* of the LCS, so I don’t know what the complexity is if you don’t
 try to actually generate the LCS, but only identify how long it is.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3953">
	<div class="div-comment" id="div-comment-3953">
<div id="comment-3953" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3953" title="comment permalink">#119</a></span>
		<span class="fn">billb</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/a9e257ca2ff9b3dd65ed1abe534fe05e.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 6, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Just to add fuel to the fire (on what might be considered the 
“other side” from the position I originally adopted), FFTW (literally 
the Fastest Fourier Transform in the West, which is portable and usually
 compettitive with vendor-optimized DFTs) is written in ANSI C by an 
OCaml code generator! See <a href="http://www.fftw.org/faq/section2.html#languages" rel="nofollow">http://www.fftw.org/faq/section2.html#languages</a><br>
 <img src="the-c-is-efficient-language-fallacy_files/icon_smile.gif" alt=":)" class="wp-smiley"> </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3954">
	<div class="div-comment" id="div-comment-3954">
<div id="comment-3954" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3954" title="comment permalink">#120</a></span>
		<span class="fn">JY</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/bc5dc31fbe03779306df2ee52fb22c09.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 6, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>I adapted the algorithm from:<br>
<a href="http://www.ics.uci.edu/%7Eeppstein/161/960229.html" rel="nofollow">http://www.ics.uci.edu/~eppstein/161/960229.html</a></p>
<p>But rereading, it looks like the auther states you can find the LCS 
directly from the matrix, making the overall computation O(mn). Hmmmn… 
maybe this is a different version of the LCS problem?</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-3957">
	<div class="div-comment" id="div-comment-3957">
<div id="comment-3957" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-3957" title="comment permalink">#121</a></span>
		<span class="fn">Camilo Pino</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/6b5a1af3e2a5d001d380352133cee697.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 7, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Just take a look at <a href="http://shootout.alioth.debian.org/gp4sandbox/benchmark.php?test=all&amp;lang=gcc&amp;lang2=javaclient" rel="nofollow">http://shootout.alioth.debian.org/gp4sandbox/benchmark.php?test=all&amp;lang=gcc&amp;lang2=javaclient</a> for a more rigorous benchmark.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-4058">
	<div class="div-comment" id="div-comment-4058">
<div id="comment-4058" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-4058" title="comment permalink">#122</a></span>
		<span class="fn"><a href="http://predelusional.blogspot.com/" rel="external nofollow" class="url">Stephen</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/f0a360fce72d3502ecce60e0af64c8c3.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 14, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>I’ve been running a matrix multiply benchmark on many machines 
since about 1982.  It is written in C, Perl, Fortran, Java, BASIC, 
Pascal, and APL.  There are two versions in C.  One uses pointers and 
the other uses arrays.  The array version looks like this:</p>
<pre>static void
matmult(void)
{
    register int i, j;
    int k;

    for (i = 0; i &lt; M; i++)
        for (j = 0; j &lt; N; j++)
            for (k = 0; k &lt; M; k++)
                c[i][j] += a[i][k] * b[k][j];
}
</pre>
<p>The pointer version looks like this:</p>
<pre>static void
matmult(void)
{
    register ARTYP *ap, *bp;            /* in order of importance */
    register int k;
    register int i;
    register int j;
    register ARTYP *cp, *aptmp;
    
    cp = &amp;c[M-1][N-1];
    ap = &amp;a[M-1][N-1];
    i = M;
    do {
        aptmp = ap;
        j = N;
        do {
            bp = &amp;b[M-1][j-1];
            k = M;
            ap = aptmp;
            do {
                *cp += *ap * *bp;
                ap--;
                bp -= M;
            } while (--k);
            cp--;
        } while (--j);
    } while (--i);
}
</pre>
<p>In the 80's, with most C compilers on most machines, the pointer 
version was faster.  This started to change in the early 90's.  These 
days, the array version is faster almost all the time.</p>
<p>The benchmarks were run with ARTYP set to "float" and also "double". 
 In the old days, "double" ran faster - sometimes twice as fast.  This 
was due to the old compilers converting float to double before doing an 
operation, then converting back.  These days, "float" is faster.</p>
<p>In the 80's, the do...while loop syntax was lower overhead than the 
"for" loop syntax.  It compiled to a simple "subtract one and branch" 
instruction.  These days it appears to make less difference.</p>
<p>Now, these benchmarks have been run using whatever was handy.  Seldom
 has a commercial compiler been handy.  Most of the systems were running
 Linux, with gcc, f77, and maybe Java was downloaded from Sun, and/or 
gcj was used.  Generally, the commercial compilers produce faster code, 
with the right options.  Over time, C has been the winner on almost 
every machine.  Fortran was second, but steadily improving with respect 
to C.  The notable exception was a supercomputer, where Fortran was much
 faster.</p>
<p>With C as the standard, Perl is about 1000x slower.  Compiled Perl is
 about 200x slower.  Java started out 300x slower, but has improved 
steadily to be only 3x slower.  Fortran started out 2x slower, but has 
steadily migrated toward C's speed.</p>
<p>Now, alot of what I do is web CGI programming.  Lots of short little 
things that put up a page and exit.  For one application, written in 
Perl, single hits were taking some 7 seconds to complete.  I decided to 
rewrite it in C.  I achieved a 30x improvement - which was less speed up
 than expected.  Further, most of the improvement came from superior 
algorithms.  Constant time is much better than exponential.  It turns 
out that things like opening files, going to databases, and just startup
 tend to dominate my work.  C is good, but so is Perl.  I'm much less 
happy with Java.  In particular, the JVMs used where I work are huge.  
Perl and C have a much smaller memory footprint, and respond faster.</p>
<p>Over time, assembly language has always been faster than C.  Here's 
how it works.  You write the thing in C, look at the instructions 
generated, and goof around with it until you have some improvement.  
There's always something you can do, so you always get something.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-4874">
	<div class="div-comment" id="div-comment-4874">
<div id="comment-4874" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-4874" title="comment permalink">#123</a></span>
		<span class="fn">Rüdiger</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/828857c63b5f0a21cce5f3e2a4903ca2.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		December 18, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>I’m not sure if it was already mentioned But you might consider 
using the c99 keyword restrict to tell the compiler that there is no 
aliasing</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-4875">
	<div class="div-comment" id="div-comment-4875">
<div id="comment-4875" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-4875" title="comment permalink">#124</a></span>
		<span class="fn"><a href="http://www.ritmark.com/" rel="external nofollow" class="url">vlad</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/f085d8dbb0892dba17534899e0ecf01e.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		December 19, 2006		<span class="report"></span>
			</div>
	<div class="content">
		<p>Mark,</p>
<p>I fully agree with your statement that today a human cannot write 
effective assembly and this is compiler who can produce really fast 
code. But I disagree that it’s impossible with c++. I’ll try to prove 
this (more or less) formally – someone already mentioned managed c++ 
here, so my point is that this generated code will in no way differ from
 a similar code generated from java or c#, so it’s either ms’s bytecode 
has a big design flaw – that it cannot be optimized for smp, or the 
opposite – which implies that it’s somehow possible to generate 
smp-optimizable c++ code. and in fact most compilers can optimize 
assuming no aliases…</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-5229">
	<div class="div-comment" id="div-comment-5229">
<div id="comment-5229" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-5229" title="comment permalink">#125</a></span>
		<span class="fn">Lars Petter Endresen</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/83d91e96b84d2503622ce96cbb301944.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		January 7, 2007		<span class="report"></span>
			</div>
	<div class="content">
		<p>&lt; !DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;<br>
<br>
<br>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><br>
<meta name="Generator" content="TextPad 4.7.3"><br>
<meta http-equiv="Content-Style-Type" content="text/css"></p>
<style type="text/css"><!--
.TPtext { color: #000000; background-color: #FFFFFF; }
.TPkeyword1 { color: #0000FF; background-color: #FFFFFF; }
.TPkeyword2 { color: #000080; background-color: #FFFFFF; }
.TPpreproc { color: #0000FF; background-color: #FFFFFF; }
.TPcomment { color: #008000; background-color: #FFFFFF; }
.TPnumber { color: #000000; background-color: #FFFFFF; }
.TPstring { color: #008080; background-color: #FFFFFF; }
.TPbracket { color: #FF0000; background-color: #FFFFFF; }
.TPoperator { color: #000000; background-color: #FFFFFF; }
--></style>
<p></p>
<p></p>
<pre>Hello,

Thank you <span class="TPkeyword1">for </span>a fascinating discussion<span class="TPoperator">!</span>

Modern compilers allow intermixing of multiple levels of parallelism,
taking advantage of whatever parallelism and locality is available:
DLP, TLP or ILP. For example, both Intel Fortran <span class="TPnumber">9.1 </span>and Intel C<span class="TPoperator">++ </span><span class="TPnumber">9.1</span>
automatically vectorizes <span class="TPbracket">(</span>DLP<span class="TPbracket">) </span>parallelizes <span class="TPbracket">(</span>TLP<span class="TPbracket">) </span>and unrolls <span class="TPbracket">(</span>ILP<span class="TPbracket">)</span>
the matrix multiplication example neatly,


<span class="TPpreproc">#include </span><span class="TPoperator">&lt;</span>stdio.h<span class="TPoperator">&gt;</span>
<span class="TPpreproc">#include </span><span class="TPoperator">&lt;</span>stdlib.h<span class="TPoperator">&gt;</span>
<span class="TPpreproc">#include </span><span class="TPoperator">&lt;</span>time.h<span class="TPoperator">&gt;</span>
<span class="TPpreproc">#define </span>SIZE <span class="TPnumber">1024</span>
<span class="TPkeyword1">float </span>a<span class="TPbracket">[</span>SIZE<span class="TPbracket">][</span>SIZE<span class="TPbracket">]</span>;
<span class="TPkeyword1">float </span>b<span class="TPbracket">[</span>SIZE<span class="TPbracket">][</span>SIZE<span class="TPbracket">]</span>;
<span class="TPkeyword1">float </span>c<span class="TPbracket">[</span>SIZE<span class="TPbracket">][</span>SIZE<span class="TPbracket">]</span>;

<span class="TPkeyword1">void </span>init_matrix<span class="TPbracket">()</span>
<span class="TPbracket">{</span>
    <span class="TPkeyword1">int </span>i, j;
    srand<span class="TPbracket">( (</span><span class="TPkeyword1">unsigned int</span><span class="TPbracket">)(</span>time<span class="TPbracket">( </span>NULL <span class="TPbracket">)) )</span>;
    <span class="TPkeyword1">for</span><span class="TPbracket">(</span>i <span class="TPoperator">= </span><span class="TPnumber">0</span>; i <span class="TPoperator">&lt; </span>SIZE; i<span class="TPoperator">++</span><span class="TPbracket">)</span>
        <span class="TPkeyword1">for</span><span class="TPbracket">(</span>j <span class="TPoperator">= </span><span class="TPnumber">0</span>; j <span class="TPoperator">&lt; </span>SIZE; j<span class="TPoperator">++</span><span class="TPbracket">)</span>
            b<span class="TPbracket">[</span>i<span class="TPbracket">][</span>j<span class="TPbracket">] </span><span class="TPoperator">= </span>a<span class="TPbracket">[</span>i<span class="TPbracket">][</span>j<span class="TPbracket">] </span><span class="TPoperator">= </span><span class="TPbracket">(</span><span class="TPkeyword1">double</span><span class="TPbracket">)</span>rand<span class="TPbracket">()</span><span class="TPoperator">/</span>RAND_MAX;
<span class="TPbracket">}</span>

<span class="TPkeyword1">void </span>matmult<span class="TPbracket">()</span>
<span class="TPbracket">{</span>
    <span class="TPkeyword1">int </span>i, j, k;
    <span class="TPkeyword1">for</span><span class="TPbracket">(</span>i <span class="TPoperator">= </span><span class="TPnumber">0</span>; i <span class="TPoperator">&lt; </span>SIZE; i<span class="TPoperator">++</span><span class="TPbracket">)</span>
        <span class="TPkeyword1">for</span><span class="TPbracket">(</span>j <span class="TPoperator">= </span><span class="TPnumber">0</span>; j <span class="TPoperator">&lt; </span>SIZE; j<span class="TPoperator">++</span><span class="TPbracket">)</span>
            <span class="TPkeyword1">for</span><span class="TPbracket">(</span>k <span class="TPoperator">= </span><span class="TPnumber">0</span>; k <span class="TPoperator">&lt; </span>SIZE; k<span class="TPoperator">++</span><span class="TPbracket">)</span>
                c<span class="TPbracket">[</span>i<span class="TPbracket">][</span>j<span class="TPbracket">] </span><span class="TPoperator">+= </span>a<span class="TPbracket">[</span>i<span class="TPbracket">][</span>k<span class="TPbracket">] </span><span class="TPoperator">* </span>b<span class="TPbracket">[</span>k<span class="TPbracket">][</span>j<span class="TPbracket">]</span>;
<span class="TPbracket">}</span>
<span class="TPkeyword1">int main</span><span class="TPbracket">(</span><span class="TPkeyword1">void</span><span class="TPbracket">)</span>
<span class="TPbracket">{</span>
    clock_t start, finish;
    init_matrix<span class="TPbracket">()</span>;
    start <span class="TPoperator">= </span>clock<span class="TPbracket">()</span>;
    matmult<span class="TPbracket">()</span>;
    finish <span class="TPoperator">= </span>clock<span class="TPbracket">()</span>;
    printf<span class="TPbracket">(</span><span class="TPstring">"\n%2.3f seconds\n"</span>, <span class="TPbracket">(</span><span class="TPkeyword1">double</span><span class="TPbracket">)(</span>finish <span class="TPoperator">- </span>start<span class="TPbracket">)</span><span class="TPoperator">/</span>CLOCKS_PER_SEC<span class="TPbracket">)</span>;
    printf<span class="TPbracket">(</span><span class="TPstring">"s=%f\n"</span>,c<span class="TPbracket">[</span><span class="TPnumber">0</span><span class="TPbracket">][</span><span class="TPnumber">0</span><span class="TPbracket">])</span>; <span class="TPcomment">// Avoid dead code elimination</span>
<span class="TPbracket">}</span>

The below code gives the asm of the unrolled and vectorized multiplication loop <span class="TPoperator">-</span>
loop is threaded too but <span class="TPkeyword2">this </span>is not shown here,

    xor         ebx,ebx
    movss       xmm0,dword ptr <span class="TPbracket">[</span>esi<span class="TPoperator">+</span>edi<span class="TPoperator">*</span><span class="TPnumber">4</span><span class="TPoperator">+</span>827500h<span class="TPbracket">]</span>
    xor         ecx,ecx
    shufps      xmm0,xmm0,<span class="TPnumber">0</span>
    movaps      xmm1,xmmword ptr <span class="TPbracket">[</span>ebx<span class="TPoperator">+</span>ecx<span class="TPoperator">*</span><span class="TPnumber">4</span><span class="TPoperator">+</span>0C2F600h<span class="TPbracket">]</span>
    movaps      xmm2,xmmword ptr <span class="TPbracket">[</span>ebx<span class="TPoperator">+</span>ecx<span class="TPoperator">*</span><span class="TPnumber">4</span><span class="TPoperator">+</span>0C2F610h<span class="TPbracket">]</span>
    movaps      xmm3,xmmword ptr <span class="TPbracket">[</span>ebx<span class="TPoperator">+</span>ecx<span class="TPoperator">*</span><span class="TPnumber">4</span><span class="TPoperator">+</span>0C2F620h<span class="TPbracket">]</span>
    movaps      xmm4,xmmword ptr <span class="TPbracket">[</span>ebx<span class="TPoperator">+</span>ecx<span class="TPoperator">*</span><span class="TPnumber">4</span><span class="TPoperator">+</span>0C2F630h<span class="TPbracket">]</span>
    mulps       xmm1,xmm0
    mulps       xmm2,xmm0
    mulps       xmm3,xmm0
    mulps       xmm4,xmm0
    addps       xmm1,xmmword ptr __pow10neg<span class="TPoperator">+</span>160h <span class="TPbracket">(</span>427400h<span class="TPbracket">)[</span>edx<span class="TPoperator">+</span>ecx<span class="TPoperator">*</span><span class="TPnumber">4</span><span class="TPbracket">]</span>
    addps       xmm2,xmmword ptr __pow10neg<span class="TPoperator">+</span>170h <span class="TPbracket">(</span>427410h<span class="TPbracket">)[</span>edx<span class="TPoperator">+</span>ecx<span class="TPoperator">*</span><span class="TPnumber">4</span><span class="TPbracket">]</span>
    addps       xmm3,xmmword ptr __pow10neg<span class="TPoperator">+</span>180h <span class="TPbracket">(</span>427420h<span class="TPbracket">)[</span>edx<span class="TPoperator">+</span>ecx<span class="TPoperator">*</span><span class="TPnumber">4</span><span class="TPbracket">]</span>
    addps       xmm4,xmmword ptr __pow10neg<span class="TPoperator">+</span>190h <span class="TPbracket">(</span>427430h<span class="TPbracket">)[</span>edx<span class="TPoperator">+</span>ecx<span class="TPoperator">*</span><span class="TPnumber">4</span><span class="TPbracket">]</span>
    movaps      xmmword ptr __pow10neg<span class="TPoperator">+</span>160h <span class="TPbracket">(</span>427400h<span class="TPbracket">)[</span>edx<span class="TPoperator">+</span>ecx<span class="TPoperator">*</span><span class="TPnumber">4</span><span class="TPbracket">]</span>,xmm1
    movaps      xmmword ptr __pow10neg<span class="TPoperator">+</span>170h <span class="TPbracket">(</span>427410h<span class="TPbracket">)[</span>edx<span class="TPoperator">+</span>ecx<span class="TPoperator">*</span><span class="TPnumber">4</span><span class="TPbracket">]</span>,xmm2
    movaps      xmmword ptr __pow10neg<span class="TPoperator">+</span>180h <span class="TPbracket">(</span>427420h<span class="TPbracket">)[</span>edx<span class="TPoperator">+</span>ecx<span class="TPoperator">*</span><span class="TPnumber">4</span><span class="TPbracket">]</span>,xmm3
    movaps      xmmword ptr __pow10neg<span class="TPoperator">+</span>190h <span class="TPbracket">(</span>427430h<span class="TPbracket">)[</span>edx<span class="TPoperator">+</span>ecx<span class="TPoperator">*</span><span class="TPnumber">4</span><span class="TPbracket">]</span>,xmm4

The present program takes about <span class="TPnumber">0.7 </span>second on my <span class="TPnumber">1.66 </span>GHz Intel Core <span class="TPnumber">2 </span>Duo CPU.
By applying special compiler options like <span class="TPoperator">/</span>O3 <span class="TPoperator">/</span>Qipo <span class="TPoperator">/</span>Qparallel the software
engineer <span class="TPkeyword1">do </span>not need to worry so much about performance; the matrix multiplication
loop is automatically threaded, vectorized and unrolled.

In my opinion Intel C<span class="TPoperator">++ </span>may at times be as fast as Intel Fortran, but it is usually
a little harder to gain the same performance in C<span class="TPoperator">++ </span>as in Fortran. The reason may be
the usage of pointers instead of fixed size arrays, and many other issues also.
Thus I tend to agree with Mark that C<span class="TPoperator">++ </span>is not always the best choice, <span class="TPkeyword1">for </span>certain
applications yes, but there are so many examples where Fortran or C is much better.

BTW: Take a look at the C99 performance of Intel C<span class="TPoperator">++</span>, <span class="TPkeyword2">using </span>restrict and the
right compiler settings may resolve many performance issues.

Best Regards,

Lars Petter Endresen
</pre>
<p><br>
</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-5393">
	<div class="div-comment" id="div-comment-5393">
<div id="comment-5393" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-5393" title="comment permalink">#126</a></span>
		<span class="fn">Lars Petter Endresen</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/83d91e96b84d2503622ce96cbb301944.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		January 11, 2007		<span class="report"></span>
			</div>
	<div class="content">
		<p>&lt; !DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;<br>
<br>
</p>
<pre>Hello,

Today I have checked the matrix-matrix product on a Intel Core 2 Duo 2.0 GHz T7200 4MB L2 CPU, with 3 different compilers. Results are as follows:

1. Intel C++ 9.1032    
   0.375 seconds  
   /O3 /QxT /Qparallel
   
2. GCC 4.1.1           
   7.5   seconds  
   -O3 -march=prescott -mfpmath=sse -msse3 -ffast-math -funroll-loops
   
3. Microsoft C++ 2005      
   8.766 seconds  
   /Ox /Ob2 /Oi /Ot /Oy /GT /GL /GS- /GR- /arch:SSE2 /fp:fast

Now, that's a big difference. Also I checked Mark's original C example, which is also easily vectorized and parallelized using Intel C++ 9.1.

for (int i=0; i &lt; 20000) {
   for (int j=0; j &lt; 20000) {
      x[i][j] = y[i-2][j+1] * y[i+1][j-2];
   }
}
 
Linking...(Intel C++ Environment)
IPO: performing single-file optimizations
IPO: generating object file ipo_29246obj.obj
.\matmult.c(35) : (col. 2) remark: LOOP WAS AUTO-PARALLELIZED.
.\matmult.c(35) : (col. 2) remark: LOOP WAS VECTORIZED.
 

So, the selection of compiler is also important, not only the selection of language. And, if you are really skilled, a C code can usually be as efficient as a Fortran code I think. I have more problems with higher level languages, as optimizing these becomes too much nitty-gritty manual work. In Fortran and C it is possible to keep it simple and make the compiler do most of the optimization, and I have not seen that higher level languages have such capabilities yet.

Best Regards,

Lars Petter Endresen


P.S: I have fixed a problem with my original test-program, c array was not initated to zero. The updated version is:


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#define SIZE 1024
float a[SIZE][SIZE];
float b[SIZE][SIZE];
float c[SIZE][SIZE];

float x[SIZE];
float y[SIZE];
float z[SIZE];

void init_matrix()
{
        int i, j;
        srand( (unsigned int)(time( NULL )) );
        for(i = 0; i &lt; SIZE; i++){
                for(j = 0; j &lt; SIZE; j++){
                        b[i][j] = a[i][j] = (double)rand()/RAND_MAX;
                        c[i][j] = 0.0;
                }
        }
}

void matmult()
{
    int i, j, k;
    for(i = 0; i &lt; SIZE; i++)
          for(j = 0; j &lt; SIZE; j++)
            for(k = 0; k &lt; SIZE; k++)
                  c[i][j] += a[i][k] * b[k][j];
}

int main(void)
{
        clock_t start, finish;
        init_matrix();
        start = clock();
        matmult();
        finish = clock();
        printf("\n%2.3f seconds\n", (double)(finish - start)/CLOCKS_PER_SEC);
        printf("s=%f\n",c[0][0]); // Avoid dead code elimination
}

</pre>
<p><br>
</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-6101">
	<div class="div-comment" id="div-comment-6101">
<div id="comment-6101" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-6101" title="comment permalink">#127</a></span>
		<span class="fn">HeWhoSpeaksOfDarkness</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/ad516503a11cd5ca435acc9bb6523536.png" class="avatar avatar-50 photo avatar-default" height="50" width="50">		
		<div></div>
		January 29, 2007		<span class="report"></span>
			</div>
	<div class="content">
		<p>MarkCC:<br>
“*despise* C++”<br>
Why do you despise it?<br>
It the only real programing language i know well so i would like to know
 why other languages are better.  Personally i find any non OO way of 
solving something very counter intuitive, but would like to change my 
intuition.  what other models work better and why?<br>
PS – any online or print references you would recommend for learning heskel? i want to braden the ways i can think</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-6103">
	<div class="div-comment" id="div-comment-6103">
<div id="comment-6103" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-6103" title="comment permalink">#128</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		January 29, 2007		<span class="report"></span>
			</div>
	<div class="content">
		<p>HeWhoSpeaksOfDarkness:</p>
<p>Why do I hate C++? </p>
<p>Because it’s a sloppy, poorly designed language with bizarre semantics and ugly syntax. </p>
<p>Templates are a wretched monstrosity – a feature designed to provide generic types which accidentally be evolved into<br>
a Turing-complete meta-language?</p>
<p>The type declarations are utterly incomprehensible, due to the pointless mix of prefix and postfix modifiers.</p>
<p>The automatic type conversions are hideous, particularly the<br>
fact that a one-argument constructor implicitly defines an automatic 
type conversion – so you can’t define a one-argument constructor without
 it turning into an implicit conversion. Back before STL, I was writing 
some code using<br>
an IBM XLC library. It <em>should have</em> been linear-time. But we 
were seeing quadratic time behavior. Turned out that there was an typo 
which caused a chain of two implicit type conversions, one of which was 
doing a complete list copy. The particularly frustrating thing about it 
was that there was  <em>no reason</em> that anyone would <em>ever</em> 
want to have that kind of type conversion happen for the collection 
types I was using – but since a one-parameter constructor is a 
type-conversion…</p>
<p>Need I mention silent truncation on assignment of subtype to 
supertype? Or the wretched mess that is built-in arrays in C++? Or the 
horrors of the preprocessor? Or the twisted mess of exception-handling? 
Or RTTI?</p>
<p>C++ is just a thorough mess. It’s a mass of ill-considered features 
that were slopped together without consideration of how they’d interact,
 and without looking at the history of other programming languages to 
see what worked and what didn’t – so that the repeated mistakes that had
 been solved <em>decades</em><em> earlier.<br>
</em></p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-6105">
	<div class="div-comment" id="div-comment-6105">
<div id="comment-6105" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-6105" title="comment permalink">#129</a></span>
		<span class="fn">HeWhoSpeaksOfDarkness</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/ad516503a11cd5ca435acc9bb6523536.png" class="avatar avatar-50 photo avatar-default" height="50" width="50">		
		<div></div>
		January 29, 2007		<span class="report"></span>
			</div>
	<div class="content">
		<p>Thanks that makes sense.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-6106">
	<div class="div-comment" id="div-comment-6106">
<div id="comment-6106" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-6106" title="comment permalink">#130</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		January 29, 2007		<span class="report"></span>
			</div>
	<div class="content">
		<p>HeWhoSpeaksOfDarkness:</p>
<p>In answer to the second part of your question:</p>
<p>It isn’t so much the object-orientation of C++ that bugs me; but I 
think it’s important for a programmer to understand more than just OO. 
OO is <em>one</em> good way of doing things – and for a lot of problems,
 it’s a fantastic way of decomposing a system into manageable pieces. 
But it’s far from the only way.</p>
<p>Here’s a list of some other great languages that are worth the time to learn. Even if you <em>never</em>
 do any real programming in them, learning them enough to be able to do 
some interesting exercises will influence your thinking about 
programming, and make you a better programmer in whatever language you 
use.</p>
<p>(1) Scheme. Everyone should have some experience with Scheme, or one 
of the other really good lisp variants. Writing Lisp code can be a 
mind-altering experience, and the way that you can create things in Lisp
 is just astonishing. I particularly recommend learning it with the SICP
 textbook linked in my sidebar.</p>
<p>(2) Prolog. Prolog is a fascinating language. It’s based on predicate
 logic, where you program by writing a description of a solution – and 
that description is interpreted to guide a search for a solution that 
matches the description. What’s particularly fascinating is that Prolog 
has an amazing kind of reversability. I’ll never forget one assignment 
from my undergrad programming languages course. We wrote a prolog 
program that took a description of an FSM and an input string as an 
input, and generated the sequence of states that the input caused the 
FSM to go through as an output. Then we took the same program, and gave 
it an input string and a sequence of states – and it generated FSMs that
 would generate that sequence of states for the specified input. And 
then we took the ame program, and gave it an FSM and a state trace – and
 it generated a list of strings that could cause that machine to go 
through that sequence of states! Amazing.</p>
<p>(3) Smalltalk. Think C++ or Java is really OO? Try doing some 
programming in Smalltalk sometime. It’ll change your mind. There’s 
object-orientation a-la C++/Java – and then there’s OO a la Smalltalk. 
They’re much more different than you’d expect!</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-6112">
	<div class="div-comment" id="div-comment-6112">
<div id="comment-6112" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-6112" title="comment permalink">#131</a></span>
		<span class="fn">HWSOD</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/ad516503a11cd5ca435acc9bb6523536.png" class="avatar avatar-50 photo avatar-default" height="50" width="50">		
		<div></div>
		January 29, 2007		<span class="report"></span>
			</div>
	<div class="content">
		<p>Wow thanks again!</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-6943">
	<div class="div-comment" id="div-comment-6943">
<div id="comment-6943" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-6943" title="comment permalink">#132</a></span>
		<span class="fn">zzo38</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/ad516503a11cd5ca435acc9bb6523536.png" class="avatar avatar-50 photo avatar-default" height="50" width="50">		
		<div></div>
		February 27, 2007		<span class="report"></span>
			</div>
	<div class="content">
		<p>So, C is still very fast, but OCaml is faster. Still, when 
programming embedded code (including Nintendo DS), C is very fast. 
Probably programming it in assembly language is faster, if you know how</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-9515">
	<div class="div-comment" id="div-comment-9515">
<div id="comment-9515" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-9515" title="comment permalink">#133</a></span>
		<span class="fn">Anonymous</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/ad516503a11cd5ca435acc9bb6523536.png" class="avatar avatar-50 photo avatar-default" height="50" width="50">		
		<div></div>
		May 25, 2007		<span class="report"></span>
			</div>
	<div class="content">
		<p>bad language i not like it</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-12848">
	<div class="div-comment" id="div-comment-12848">
<div id="comment-12848" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-12848" title="comment permalink">#134</a></span>
		<span class="fn">HeadMonkey</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/a4c714ff2065d960fbcd07687f43edeb.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 20, 2007		<span class="report"></span>
			</div>
	<div class="content">
		<p>“In C and C++, there’s no such thing as an array – there’s just pointers…”<br>
Is this proof that your phd is just an expensive piece of paper hanging on the wall ?</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-12859">
	<div class="div-comment" id="div-comment-12859">
<div id="comment-12859" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-12859" title="comment permalink">#135</a></span>
		<span class="fn">Xanthir, FCD</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/37881c0540fb86ebfa6c855e61021527.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 20, 2007		<span class="report"></span>
			</div>
	<div class="content">
		<p>Care to elaborate, HeadMonkey?  I suspect this was just a drive-by defacement, but if you *do* return, please expand this.</p>
<p>Because, um, that really is all arrays are in C/C++.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-12870">
	<div class="div-comment" id="div-comment-12870">
<div id="comment-12870" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-12870" title="comment permalink">#136</a></span>
		<span class="fn">HeadMonkey</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/a4c714ff2065d960fbcd07687f43edeb.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		November 21, 2007		<span class="report"></span>
			</div>
	<div class="content">
		<p>I’m sure you are qualified to go and read the various C standards. I
 think you’ll find that they use the word ‘array’ somewhere in them, as 
well as the restrictions the standards place on compilers as to their 
behavior.</p>
<p>Also, the AMD x86 Code Optimization Guide has a nice chapter on why 
arrays can be faster than pointers. Just because the C standard says 
that a reference to a non-indexed array, is interpreted, by the 
compiler, to be a pointer to the start of that array, does not mean that
 “arrays are pointers.” Compilers are able to make various optimizations
 at compile time on array based code, involving memory location 
aliasing, that cant otherwise be made when using pointers.</p>
<p>Also, not to add insult to injury here, but the statement “They’re 
good at things that need to get very close to the hardware – not in the 
efficiency sense, but in the sense of needing to be able to fairly 
directly munge the stack, address specific hardware registers, etc.” is 
just as bogus as the “arrays are pointers” statement. C, and so far as I
 know, C++ ( im not a ++ programmer so someone please correct me if this
 is wrong ) do not provide “direct access to hardware registers” … this 
is implemented as inlined assembly, for whatever platform is being coded
 for, and is not part of any C or C++ language specification.</p>
<p>This article seems to be, nothing more than, a justification for a 
language the author doesn’t like, based on false assumptions and a 
misunderstanding of the difference between “Library Code A” and 
“Compiler Implementation B.” It’s definitely not an apples to apples 
comparison.</p>
<p>Let me know if the school decides to refund your phd monies.</p>
<p>ps. C will also let you execute code stored at an offset in memory, 
by writing machine language to that memory location and using a function
 pointer. In this regard, you could say, C will let you execute any 
valid machine code that your cpu and/or hardware supports. Therefore, 
for any given hardware, C will allow you to execute all combinations of 
valid machine code, and in this manner, can run as fast as the hardware 
allows. The best any language that does not support this ability can do,
 is match its speed. However, this assumes a programmer with the 
knowledge required to write valid assembly, or a C library to do this 
for him/her, and I don’t think the article was really talking about this
 scenario, as it involves optimized assembly language programming. 
Nevertheless, C will let you do it <img src="the-c-is-efficient-language-fallacy_files/icon_wink.gif" alt=";)" class="wp-smiley"> </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-16030">
	<div class="div-comment" id="div-comment-16030">
<div id="comment-16030" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-16030" title="comment permalink">#137</a></span>
		<span class="fn">Henrique</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/ad516503a11cd5ca435acc9bb6523536.png" class="avatar avatar-50 photo avatar-default" height="50" width="50">		
		<div></div>
		May 20, 2008		<span class="report"></span>
			</div>
	<div class="content">
		<p>The idea about aliased pointers is reasonable, but you are using a 
wrong argument. The C language _has_ a way to avoid aliases using the 
restrict keyword. Consider this code:</p>
<p>void multiply(float * restrict * restrict x, float * restrict * restrict y)<br>
{<br>
	for (int i=0; i &lt; 20000; i++)<br>
	   for (int j=0; j &lt; 20000; j++)<br>
	      x[i][j] = y[i-2][j+1] * y[i+1][j-2];<br>
}</p>
<p>$ gcc -c -O2 -ftree-vectorize -ftree-vectorizer-verbose=2 -std=c99 -msse hard-vectorize.c</p>
<p>hard-vectorize.c:4: note: LOOP VECTORIZED.<br>
hard-vectorize.c:2: note: vectorized 1 loops in function.</p>
<p>Also, there’s no such thing as C/C++. There’s no language called 
C/C++. There is the C language, which has the restrict keyword and the 
C++ which does not.</p>
<p>The counter argument is that C programmers are aware of the problem 
and use (highly optimized) matrix multipliers hand-written in assembly 
code. See the ATLAS project (a BLAS clone), for example.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20147">
	<div class="div-comment" id="div-comment-20147">
<div id="comment-20147" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20147" title="comment permalink">#138</a></span>
		<span class="fn">Chris L.</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/5624e9226db8721c569351175f361bd7.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		May 4, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>Working on compilers for one of the biggest vendors, I like to pretend I know a little about this stuff sometimes.</p>
<p>C and C++ are both pretty bad at aliasing. Compilers work hard to 
avoid the issue, but the truth is Fortran and other high performance 
languages are considerably better at that problem. Essentially, free 
pointers cause more register spill, less auto-vectorization and 
auto-parallelization, greater stack consumption, and so on, because the 
compiler has to use loose and approximate aliasing rules such as 
type-based aliasing. The problem is at the language level. For some 
simple numeric code like matrix multiply and the like one can use 
`restrict` to gain some of the Fortran subroutine aliasing rules, but 
the problem is systemic to these free-pointer languages.</p>
<p>in Fortran, one can say:</p>
<p>integer, target :: i<br>
integer, pointer :: p<br>
call sub foo(p)<br>
contains<br>
subroutine foo(a)<br>
…</p>
<p>and then if those are the two declarations, the compiler can actually
 optimize the pointer away, and replace all accesses of P with a direct 
access of I. This saves a register, saves an indirect load from an 
address, and it lets you apply this optimization transitively to the 
body of foo. </p>
<p>All of this is possible because i is the only possible target of i in
 this compilation unit. C pointers can point at all sorts of things, and
 some users expect this behaviour (casting their pointer types, for 
example) so even loosey-goosey type-based aliasing isn’t possible. </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20148">
	<div class="div-comment" id="div-comment-20148">
<div id="comment-20148" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20148" title="comment permalink">#139</a></span>
		<span class="fn">Anonymous</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/ad516503a11cd5ca435acc9bb6523536.png" class="avatar avatar-50 photo avatar-default" height="50" width="50">		
		<div></div>
		May 4, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>Just use the native SIMD types and intrinsics.  They’ll be 
available in C and almost certainly *not* available in any other 
language.  The resulting code will out-perform anything a compiler can 
come up with.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20149">
	<div class="div-comment" id="div-comment-20149">
<div id="comment-20149" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20149" title="comment permalink">#140</a></span>
		<span class="fn">Ken</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/97d540da0aee796ba07e9420099552b4.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		May 4, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>I wouldn’t even bother responding to the greythumb.org guys.  If they say:</p>
<p>“To give you an idea of just how much faster C can be for tasks like 
this, I have found that evolvable instruction set based evolutionary 
computation is almost twice as fast when competently implemented in C 
than a similar competent implementation in Java.”</p>
<p>I say, wow, almost twice as fast?  I’d give up 50 of my performance 
in a heartbeat if it meant I’d get increased reliability.  Heck, I’ve 
got a dual-core CPU here with one core sitting idle 99.9%+ of the time. 
 I have a desktop C++ app crash at least once a week (often Firefox, but
 frequently others).  Recreating my work after something dies is a lot 
more painful than a slightly slow computer.</p>
<p>And this was the best example they could find?  Ouch.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20154">
	<div class="div-comment" id="div-comment-20154">
<div id="comment-20154" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20154" title="comment permalink">#141</a></span>
		<span class="fn">Anonymous</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/ad516503a11cd5ca435acc9bb6523536.png" class="avatar avatar-50 photo avatar-default" height="50" width="50">		
		<div></div>
		May 5, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>c++/c is not for parallel execution.  If you really need it, why don’t you use OpenMP with c++/c?</p>
<p>The real thing is that compiler still cannot beat the carefully crafted c/c++ program in most cases.</p>
<p>And I doubt the different between c/c++ in your benchmark. What is 
the reason that they are different? I don’t see any reason that LCS 
needs virtual functions and such, so c/c++ performance should be the 
same.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20158">
	<div class="div-comment" id="div-comment-20158">
<div id="comment-20158" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20158" title="comment permalink">#142</a></span>
		<span class="fn">Anonymous</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/ad516503a11cd5ca435acc9bb6523536.png" class="avatar avatar-50 photo avatar-default" height="50" width="50">		
		<div></div>
		May 5, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>i see you include some C++ code, are you sure that even compiles?</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20159">
	<div class="div-comment" id="div-comment-20159">
<div id="comment-20159" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20159" title="comment permalink">#143</a></span>
		<span class="fn"><a href="http://ru-linux-geek.livejournal.com/" rel="external nofollow" class="url">Rob</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/78da0e31d84156665b2041cbea69742e.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		May 5, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>Isn’t the naive DP solution to LCS O(n^<b>2</b>) (not O(n^3)) time and space?</p>
<p>The recursion only requires looking at O(1) other cells to determine the value for the current cell.</p>
<p><a href="http://en.wikipedia.org/wiki/Longest_common_subsequence_problem" rel="nofollow">http://en.wikipedia.org/wiki/Longest_common_subsequence_problem</a></p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20160">
	<div class="div-comment" id="div-comment-20160">
<div id="comment-20160" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20160" title="comment permalink">#144</a></span>
		<span class="fn">Josh Weissman</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/bb3316650dcec945a678e4299b073656.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		May 5, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>I believe you were referring to Didier Verna’s paper “How to make Lisp go faster than C”</p>
<p>Here’s a link, for others to read…</p>
<p><a href="http://www.lrde.epita.fr/%7Edidier/research/verna.06.imecs.pdf" rel="nofollow">http://www.lrde.epita.fr/~didier/research/verna.06.imecs.pdf</a></p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20161">
	<div class="div-comment" id="div-comment-20161">
<div id="comment-20161" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20161" title="comment permalink">#145</a></span>
		<span class="fn">Shane</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/ad516503a11cd5ca435acc9bb6523536.png" class="avatar avatar-50 photo avatar-default" height="50" width="50">		
		<div></div>
		May 5, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>I don’t understand why everyone in the comments is getting bent out
 of shape about this article.  I thought it was a great rebuttal to the 
cited article and didn’t imply that one should never use C or C++.  It 
was merely correcting the notion that C or C++ aren’t the only game in 
town for speed, and it had numbers to back up that claim.  What more do 
you want?  </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20162">
	<div class="div-comment" id="div-comment-20162">
<div id="comment-20162" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20162" title="comment permalink">#146</a></span>
		<span class="fn"><a href="http://www.jacksonleung.com/" rel="external nofollow" class="url">Jackson</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d1e9ee81a39250e7ecc72a9c4d1d2a13.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		May 5, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>I think the reason why there is so much speculation, is due to the 
coders haven’t a hard time believing that the code used in this 
experiment was actually that efficient. There could be problems in the 
code, and problems in the compilation. If this article had listed the 
code for all the languages, and the various ways it was compiled, then 
I’m sure the comments list would be much shorter. Nevertheless, an 
interest article. If Ocaml is really that fast, then I know what 
languages password crackers are going to come in.something.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20163">
	<div class="div-comment" id="div-comment-20163">
<div id="comment-20163" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20163" title="comment permalink">#147</a></span>
		<span class="fn">Scott R.</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/7f598e22138de97ad8883e5990af3677.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		May 5, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>No doubt this is why most video game rendering engines, video, 
audio and image editing software is written in OCaml and not C or C++.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20164">
	<div class="div-comment" id="div-comment-20164">
<div id="comment-20164" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20164" title="comment permalink">#148</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		May 5, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>Re #147:</p>
<p>I’ve been trying to ignore the new comments here, since they’re 
mostly just repeats of stuff from a two-year-old post. But this is just 
particularly stupid. It’s basically the old bullshit argument that 
popularity implies quality – the same argument that Britney Spears music
 is better that Bach – after all, who sells more records?</p>
<p>(A) Where in the world is there a group of programmers who always 
have the option to use the best possible tools for what they’re doing? I
 work at Google, one of the coolest, most dynamic, creative, open 
workplaces anywhere – and I don’t get to choose any programming language
 I want; I’m constrained by lots of other factors. Some of my code might
 be as fast or faster written in OCaml instead of C++ – but the fact 
that upwards of 90% of the engineers at Google have a deep understanding
 C++, and probably less that 5% (if that many) know Ocaml means that 
OCaml isn’t a good choice for typical Google projects.</p>
<p>(B) Even if the social aspects of development don’t restrict language
 choices, practical ones often do. You can’t use a language that doesn’t
 exist on your platform. If I want to write a mapreduce<br>
at Google, I can’t write it in a language that doesn’t run on our 
computing infrastructure. Even if I could write a reducer that in some 
language that was ten times faster than it would be in C++, it wouldn’t 
matter. That’s the story for most video games systems: they’re writing 
programs for very unusual hardware, and they have to use the languages 
that have support for those environments. Even if there’s a brilliant 
language that could, in theory, let them write faster code, it wouldn’t 
matter unless someone ported it and integrated the necessary support.</p>
<p>(C) Even given the social and technical ability to use alternate languages, <em>most programmers don’t know about them</em>.
 Unfamiliarity/obscurity is a killer. A few years back, there was a 
wonderful language called Sisal, which was targeted at the kinds of 
scientific applications that are normally written in Fortran. Sisal 
achieved uniformly better performance than Fortran; it took better 
advantage of vector processing, was able to automatically do more in 
parallel. It was pretty much <em>never</em> slower than Fortran, and on 
real applications, generally managed to be at least 20% faster (and in 
scientific applications, getting a 2% speedup was considered 
significant). How much computational fluid flow code is written in 
Sisal? None. It’s pretty much all Fortran. Because the physicists that 
write most of the CFF know Fortran.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20165">
	<div class="div-comment" id="div-comment-20165">
<div id="comment-20165" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20165" title="comment permalink">#149</a></span>
		<span class="fn">Matthew</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/ad516503a11cd5ca435acc9bb6523536.png" class="avatar avatar-50 photo avatar-default" height="50" width="50">		
		<div></div>
		May 5, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<blockquote><p>No doubt this is why most video game rendering engines,
 video, audio and image editing software is written in OCaml and not C 
or C++</p></blockquote>
<p>Software also has external constraints to deal with.  There are 
probably a lot more libraries for game developers to use in C and C++ 
than in OCaml.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20167">
	<div class="div-comment" id="div-comment-20167">
<div id="comment-20167" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20167" title="comment permalink">#150</a></span>
		<span class="fn">Bob Foster</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/30de25d1d65da4ea6756cbe43a384530.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		May 5, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>One anecdote does not an argument make. You wrote the C code. 
Perhaps you’re not a good C programmer. You don’t say what compiler you 
tested with with what level of optimization. In fact, I’m so deeply 
suspicious about the interpreted OCaml beating compiled C that I suspect
 you chose the example to show how great OCaml is. You’re correct that C
 is not a good language for numerical applications and FORTRAN is, so  
if you were doing a numerical application that required sophisticated 
array optimizations where are the numbers for optimized FORTRAN?</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20168">
	<div class="div-comment" id="div-comment-20168">
<div id="comment-20168" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20168" title="comment permalink">#151</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		May 5, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>For goodness sakes, read the original fucking post.</p>
<p>First – this stuff is old. This post is 2 1/2 years old. The experiment was at least 4 years before that!</p>
<p>Second – I had *no* reason to bias the experiment. I went in with no 
preference, and I wanted to know what would give me the performance I 
needed. I included OCaml based on the recommendation of a *very* smart 
friend. (In fact, my preferred outcome would have been Java, since that 
was what I’d been working in at the time.)</p>
<p>Third – it wasn’t a numerical program. It was longest common 
subsequence. And it was for an SCM system. So Fortran wasn’t an option.</p>
<p>Fourth – the way that I got involved in the project was by being on 
the team that implemented a C++ compiler. So I do know a thing or two 
about how to write good C code. </p>
<p>Fifth – the point of the experiment wasn’t just to find the fastest –
 it was to find a complexity/speed balance. My expectation was that raw C
 would be the best, with C++ a close second, but that the complexity 
would be worst for C. The code *deliberately* wasn’t hand-optimized. It 
was written for clarity.</p>
<p>Finally – OCaml uses a remarkable interpreter. I was absolutely 
astonished by the results, and even 7 or 8 years after first studying 
how it works, still marvel at it. It’s truly brilliant. There’s very 
little difference between OCaml interpreted code, and native compiled 
code; for most opcodes, the “interpretation” of code loaded into the 
interpreter is <em>one</em> machine instruction – an indirect jump. Take
 a shallow interpreter like that, combine it with aggressive inlining, 
and you get seriously kick-ass code. I’m not *nearly* smart enough to 
have written it; but I am start enough to take advantage of brilliant 
work done by someone else.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20169">
	<div class="div-comment" id="div-comment-20169">
<div id="comment-20169" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20169" title="comment permalink">#152</a></span>
		<span class="fn">Anonymous</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/ad516503a11cd5ca435acc9bb6523536.png" class="avatar avatar-50 photo avatar-default" height="50" width="50">		
		<div></div>
		May 5, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>Don’t forget the correlation IS causation!</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20170">
	<div class="div-comment" id="div-comment-20170">
<div id="comment-20170" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20170" title="comment permalink">#153</a></span>
		<span class="fn">Anonymous</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/62981c276f4fef3c8da9743f49177a55.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		May 6, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>Don’t forget the correlation IS causation!</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20171">
	<div class="div-comment" id="div-comment-20171">
<div id="comment-20171" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20171" title="comment permalink">#154</a></span>
		<span class="fn"><a href="http://yourtvonline.com/" rel="external nofollow" class="url">ann</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/ec5bf5121f67871ee733b837ee41c4e1.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		May 6, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>check <a href="http://yourtvonline.com/" rel="nofollow">http://yourtvonline.com</a></p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20172">
	<div class="div-comment" id="div-comment-20172">
<div id="comment-20172" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20172" title="comment permalink">#155</a></span>
		<span class="fn"><a href="http://bannalia.blogspot.com/" rel="external nofollow" class="url">Joaquín M López Muñoz</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/3ad977776c5e6d620d561e82aa66a2f0.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		May 6, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>I know this thread had probably gotten too long for your taste, but
 there’s one particular detail I’d like to comment on: you registered 
the following times for C and C++, respectively:</p>
<p>· C: 0.8 seconds.<br>
· C++: 2.3 seconds.</p>
<p>How come the C++ program was almost 3x slower than the C program? For
 starters, you could have compiled the C code with your C++ compiler 
(modulo negligible incompatibilities between both languages) and should 
have gotten the same performance (modulo compiler quality), so either 
your C++ compiler was really poor or your C++ code differed in 
significant ways from the C code. Maybe you can shed some light on this?</p>
<p>Thank you,</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20173">
	<div class="div-comment" id="div-comment-20173">
<div id="comment-20173" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20173" title="comment permalink">#156</a></span>
		<span class="fn"><a href="http://tech.xster.net/" rel="external nofollow" class="url">Xiao</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/85e4239ff9662bf8296083d98da17677.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		May 6, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>I just think the author of the original site probably meant that C 
won’t be replaced by the newer “cooler” languages like .net/java/python 
etc which you proved to be true with your own experimentations. It’s 
probably not a claim for them to be the best languages ever</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20174">
	<div class="div-comment" id="div-comment-20174">
<div id="comment-20174" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20174" title="comment permalink">#157</a></span>
		<span class="fn">SK</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/477152a731fa2786681900246d689637.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		May 6, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>If Mark doesn’t know the difference between int x[100] and int *x =
 malloc (100 * sizeof(int)) then I have to take his evaluation of C with
 a pinch, no, a pound of salt. Also, for the example mentioned, you can 
always check for array overlaps using simple pointer and length 
comparison. Heck, that’s how memmove works properly when the src and 
dest overlap.</p>
<p>I agree that the C compiler isn’t going to parallelize every loop 
that can be parallelized. May be if you play around with the 
optimization flags and ask it to optimize for speed and not size, then 
it might end up parallelizing part of the loop. But I wouldn’t expect 
Mark to be a master at C compiler optimization flags.</p>
<p>Sorry, to sound like a fan boy, but if you are going to criticize a 
language or evaluate it, you better be an expert on it before you go 
around bad mouthing it. Your evaluation just tells you that _you_ 
personally can write the most efficient code only in OCaml.</p>
<p>I’m not saying C is the best, just that this evaluation is bollocks.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20177">
	<div class="div-comment" id="div-comment-20177">
<div id="comment-20177" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20177" title="comment permalink">#158</a></span>
		<span class="fn">dagome</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/4b990c4807e68671f305c86e8d047073.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		May 6, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<blockquote><p>That pointer based nature means that in a C or C++ 
program, it’s very hard for a compiler to figure out what things are 
independent.</p></blockquote>
<p>Many users have mentioned the restrict keyword, but technically, the 
compiler does not have to figure out the may-aliase question for x and 
y. It can force the issue by generating an explicit check:</p>
<pre>  if( x &amp; y overlap )
      unoptimized original
  else
      optimized code
</pre>
<p>This has the obvious drawback of code bloat, but that’s probably not 
an issue for small inner loops like your example. I suspect that the 
issue is less to do with C and C++ as languages, than it is with the 
fact that C/C++ compiler writers have not targeted numeric code. (Which 
may in part be a self-fulling prophecy, given that writers of numeric 
code are happy with Fortran.)</p>
<p>Regarding language issues, I would think the explicitly parallel 
constructs of high-performance Fortran (e.g., forall) are a better 
example of a “built-in” advantage over C for numeric domains.</p>
<p>Also, numeric analysis is only one domain. C/C++ are likely to really
 excel when explicit memory management is important. (Note this has 
nothing to do with “getting very close to the hardware.”)</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20178">
	<div class="div-comment" id="div-comment-20178">
<div id="comment-20178" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20178" title="comment permalink">#159</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		May 6, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>Re #155:</p>
<p>In an acronym, STL.</p>
<p>As I said in the original post – the experiment wasn’t originally 
just about speed. I was implementing an SCM system – which is a complex 
system that includes a couple of CPU intensive algorithms, as well as a 
whole lot of complex data manipulation. I was looking for a balance of 
speed and expressiveness – speed for making the intensive algorithms 
fast, and expressiveness to make it easier to implement the more 
semantically complex code.</p>
<p>The C code was raw, bare-bones C: arrays and pointer arithmetic all the way. </p>
<p>For C++, I didn’t just translate the C code to C++; I tried to take 
advantage of the expressiveness of C++. So instead of a pointer to an 
array of char*s, I used a vector of pointers to strings. That was, 
pretty much, the entire difference between the C++ and the C: in C++, I 
used vector<string *="">, whereas in C I used char**. </string></p>
<p></p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20180">
	<div class="div-comment" id="div-comment-20180">
<div id="comment-20180" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20180" title="comment permalink">#160</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		May 6, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>Re #158:</p>
<p>It’s not as simple as just adding an overlap check like that. Try 
looking up array independence checking in a decent optimization 
textbook. Sometimes you can vectorize or parallelize code even on 
overlapping arrays, provided you can prove certain data independence 
properties.  But if you can’t be sure whether the arrays are aliased,<br>
or if there are aliased pointers to elements of the array, you can’t prove the indepedence properties.</p>
<p>Of course C/C++ is really good for some things. I never intended to 
suggest otherwise.  But it’s *not* the be-all end-all of efficient 
programming languages. The entire point of this post was that the idea 
that C/C++ is the *ultimate* in efficiency for *all* applications is 
wrong. For *some* application domains, C/C++ is absolutely the best 
choice – both for reasons of efficiency and expressiveness. But for many
 other domains,<br>
it’s an awful choice, for a variety of reasons.</p>
<p>I’m also *incredibly* skeptical of people who claim manual memory 
management as a performance benefit. My own experience in multiple 
applications is that it’s as likely to cause *inferior* performance as 
it is to improve performance. Once again, it depends very much on the 
problem domain: there are tons of applications where some kind of manual
 memory allocation is simple, maintainable, and super fast. There are 
also tons of applications where manual memory management is complex, 
slow, and error prone. GC can kick the ass of manual memory management 
for some problems.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20217">
	<div class="div-comment" id="div-comment-20217">
<div id="comment-20217" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20217" title="comment permalink">#161</a></span>
		<span class="fn">dagome</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/4b990c4807e68671f305c86e8d047073.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		May 8, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>Re #160:</p>
<p>I’m not as up on array vectorization optimizations as I could be, but
 I’ll stick by the original point. It is not always necessary for the 
compiler to statically identify potential aliases in order to apply loop
 and array optimizations. In many cases — such as the example presented 
here — it is easy and relatively cheap to put in disambiguating dynamic 
checks.</p>
<p>I suppose I am only moderately (not *incredibly*) skeptical of 
automatic GC beating manual memory management for most applications, but
 “each wins for certain problems” is hard to disagree with. For my part,
 I also would not argue with “C/C++ is good for some things and bad for 
others.” I just meant to emphasize that “proximity to hardware” might 
not be their only strong point.</p>
<p>At any rate, I would be interested to hear more about problem domains
 where /performance/ of GC clearly dominates (or even consistently 
matches) manual collection. (Outside of performance, GC is clearly the 
bee’s knees.) While there’s been a lot of research into memory 
management, I have the impression that it’s still a rich area to 
explore. For example, I’ve seen the choice of malloc implementation have
 a huge impact on performance. (Even “manual” memory management is still
 pretty abstracted.)</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20269">
	<div class="div-comment" id="div-comment-20269">
<div id="comment-20269" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20269" title="comment permalink">#162</a></span>
		<span class="fn">anonymous</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/ad516503a11cd5ca435acc9bb6523536.png" class="avatar avatar-50 photo avatar-default" height="50" width="50">		
		<div></div>
		May 11, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>This is a response to #128</p>
<p>Since 1995 and definitely with the introduction of ISO C++ (1998) the
 problem with the conversion constructors is solved. It is possible to 
prevent such conversions. This lead us to the important question why you
 don’t know about that fact in 2006?</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20270">
	<div class="div-comment" id="div-comment-20270">
<div id="comment-20270" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20270" title="comment permalink">#163</a></span>
		<span class="fn">Mark C. Chu-Carroll</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/d91cbc789ef67801e927e627a583b5a4.jpeg" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		May 11, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>Gosh, I dunno, maybe because that particular incident happened in 
1994? (Note that I specifically mentioned that it was pre-STL. That 
particular problem happened when I was a summer student working at IBM 
to port the Concert/C distributed programming constructs to C++.)</p>
<p>Further, the fact that you <em>can</em> write C++ code in a way that 
prevents things like conversions, that doesn’t mean that library code 
uses them. The specific problem that I was talking about was in a 
library. The fact that C++ includes that kind of implicit type 
conversion is, in my opinion, a serious flaw in the language. The cases 
where it’s actually really beneficial are, in my experience, very 
limited; the cases where it causes unexpected problems are very common. 
It’s a lousy tradeoff. </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-20271">
	<div class="div-comment" id="div-comment-20271">
<div id="comment-20271" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-20271" title="comment permalink">#164</a></span>
		<span class="fn">borofergie</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/b3173217a49b5b0116078775a17eb21d.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		May 11, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>How is it that the “big 3″ commercial CFD codes, Fluent, STAR-CCM+ 
and CFD all dumped FORTRAN a long time ago in favour of C/C++?</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-21826">
	<div class="div-comment" id="div-comment-21826">
<div id="comment-21826" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-21826" title="comment permalink">#165</a></span>
		<span class="fn">Graham</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/36d3ef408652b1f08276036cf45e2f1c.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		August 11, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>These articles are funny.   </p>
<p>“Finally after all these years, this one guy has demonstrated that C/C++ is not efficient.”  What hubris and arrogance.</p>
<p>A couple of the comments after the article straightens things out.</p>
<p>One item of note:</p>
<p>The author is not fundamentally wrong about C/C++ alias detection 
issues for optimization purposes.  Yet, the example is contrived.  </p>
<p>No reasonable C/C++ engineer would create a nested loop, as described, if fast execution for numerical computing was desired.  </p>
<p>They would use a library(ies) that handles optimization:</p>
<p> <a href="http://www.boost.org/doc/libs?view=category_Math" rel="nofollow">http://www.boost.org/doc/libs?view=category_Math</a></p>
<p>..or create their own library.  Other opportunities, such as GPGPU (CUDA, OpenCL) also exist. </p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-21999">
	<div class="div-comment" id="div-comment-21999">
<div id="comment-21999" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-21999" title="comment permalink">#166</a></span>
		<span class="fn">Lauren</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/36f88fa9edebcabf6e172aa3948f0e94.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		August 14, 2009		<span class="report"></span>
			</div>
	<div class="content">
		<p>I saw your article by searching some key words on internet and I am
 very glad to read completely your article now. Wow, I am highly respect
 that you have much experience about programming. But it’s not easy for 
me to do this since my English is not very good. I can pratice my 
English reading ability and programming knowledge by reading your web 
site. </p>
<p>I am a software engineer in Taiwan. I always think that it’s very 
important to enhance software effectiveness. In this time, since we 
regard as we have a faster CPU and cheaper RAM, many people design 
software without careful planning and implementing. It’s not a correct 
attitude, oppositely, we must to develop web or pc software as attentive
 as developing the feature phone or mobile phone. As possible as 
perfect, we must distinguish all of technologies; understand the 
computing method and OS, and familiar with relating platform structure 
and principle. We just probably can create the perfect system.</p>
<p>If my English is good enough, I can describe much correctly. The 
language is indeed a barrier for knowledge sharing. Isn’t it? Please 
give me some advices. Thanks ^_^</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-24846">
	<div class="div-comment" id="div-comment-24846">
<div id="comment-24846" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-24846" title="comment permalink">#167</a></span>
		<span class="fn"><a href="http://so4pro.blogspot.com/" rel="external nofollow" class="url">so4pro</a></span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/221e2b02860623f81d7d1bd2870d5de6.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		March 23, 2010		<span class="report"></span>
			</div>
	<div class="content">
		<p>I know this thread had probably gotten too long for your taste, but
 there’s one particular detail I’d like to comment on: you registered 
the following times for C and C++, respectively:</p>
<p>· C: 0.8 seconds.<br>
· C++: 2.3 seconds.</p>
<p>How come the C++ program was almost 3x slower than the C program? For
 starters, you could have compiled the C code with your C++ compiler 
(modulo negligible incompatibilities between both languages) and should 
have gotten the same performance (modulo compiler quality), so either 
your C++ compiler was really poor or your C++ code differed in 
significant ways from the C code. Maybe you can shed some light on this?</p>
<p>Thank you,</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-25994">
	<div class="div-comment" id="div-comment-25994">
<div id="comment-25994" class="comment odd alt thread-odd thread-alt depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-25994" title="comment permalink">#168</a></span>
		<span class="fn">Anonymous</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/ad516503a11cd5ca435acc9bb6523536.png" class="avatar avatar-50 photo avatar-default" height="50" width="50">		
		<div></div>
		July 23, 2010		<span class="report"></span>
			</div>
	<div class="content">
		<p>Download cygwin and run this :<br>
$ find Program\ Files/ -name ‘*exe’ -exec strings {} \;  | grep  MSVCRT.dll</p>
<p>or if you’re cool, run this on your linux box:<br>
find /usr/bin -type f -exec grep GLIBC</p>
<p>If you’re on Apple, you’re an artistic genius and don’t need to worry
 about the details.  Just keep on facetweeting or whatever, don’t worry 
about this thread.</p>
<p>Yup.  Your whole world is built on C.</p>
<p>I’ll bottom line this:<br>
1) C rules and your toy language is built on it.<br>
2) Ocaml or fortran of jythonaskell whatever is NOT faster.<br>
3) Evidence otherwise is contrived.<br>
4) Assembly is only thing that might be faster.<br>
5) If you’re parsing your “monster” 10000 line text file, just stick with perl and shut up.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->

<li class="li-comment" id="li-comment-25995">
	<div class="div-comment" id="div-comment-25995">
<div id="comment-25995" class="comment even thread-even depth-1 reply">
	<div class="header">
		<span class="comment-link"><a href="#comment-25995" title="comment permalink">#169</a></span>
		<span class="fn">joe_one_comment</span>
		<img alt="" src="the-c-is-efficient-language-fallacy_files/cc1ef758264db1feae2b02f200365db9.png" class="avatar avatar-50 photo" height="50" width="50">		
		<div></div>
		July 23, 2010		<span class="report"></span>
			</div>
	<div class="content">
		<p>Download cygwin and run this :<br>
$ find Program\ Files/ -name ‘*exe’ -exec strings {} \;  | grep  MSVCRT.dll</p>
<p>or if you’re cool, run this on your linux box:<br>
find /usr/bin -type f -exec grep GLIBC</p>
<p>If you’re on Apple, you’re an artistic genius and don’t need to worry
 about the details.  Just keep on facetweeting or whatever, don’t worry 
about this thread.</p>
<p>Yup.  Your whole world is built on C.</p>
<p>I’ll bottom line this:<br>
1) C rules and your toy language is built on it.<br>
2) Ocaml or fortran of jythonaskell whatever is NOT faster.<br>
3) Evidence otherwise is contrived.<br>
4) Assembly is only thing that might be faster.<br>
5) If you’re parsing your “monster” 10000 line text file, just stick with perl and shut up.</p>
	</div>
</div><!--/comment-->	</div>
</li><!-- #comment-## -->
</ol></div><!--/comments-->		</div><!--/content-->
		<div id="sidebar">
			<div class="sb-ad"></div><div id="search-2" class="widget clearfix widget_search">
	<h2 class="widget-title">Search This Blog</h2>
	<form role="search" method="get" id="searchform" action="http://scienceblogs.com/goodmath/">
		<div>
			<label class="screen-reader-text" for="s">Search for:</label>
			<input name="s" id="s" type="text">
			<input id="searchsubmit" value="Search" type="submit">
		</div>
	</form>
</div>
<div id="ngs_subscribe-2" class="widget clearfix widget-ngs-subscribe">
	<h2 class="widget-title">Subscribe</h2>
	<span class="accessibility">Subscribe via:</span>
	<ul class="nav">
		<li>
			<a class="imr imr-rss" href="http://scienceblogs.com/goodmath/feed/">RSS2</a>
		</li>
		<li>
			<a class="imr imr-atom" href="http://scienceblogs.com/goodmath/feed/atom/">Atom</a>
		</li>
		<li class="help">
			Subscribe via a feed reader		</li>
	</ul>
</div>

<div class="sb-sponsor">
<script type="text/javascript"><!--
google_ad_client = "ca-pub-2369179702655127";
/* SB rectangle */
google_ad_slot = "3359226996";
google_ad_width = 300;
google_ad_height = 250;
//-->
</script>

<script type="text/javascript" src="the-c-is-efficient-language-fallacy_files/show_ads.js"></script>

</div>
<div class="widget">
	<h2 class="widget-title">No Widgets Yet!</h2>
	<p>It looks like you haven’t added any widgets to this sidebar yet. To customize this sidebar, go <a href="http://scienceblogs.com/goodmath/wp-admin/widgets.php">add some</a>!</p>
</div>		</div><!--/sidebar-->
	</div><!--/str-inside-->
</div><!--/main-->

	<hr class="hidden">
	<div class="footer-wrapper">
		<div id="footer">
			<ul class="footer-links">
						</ul>
 			<div class="copyright">© 2006-2013 ScienceBlogs LLC. ScienceBlogs is a registered trademark of ScienceBlogs LLC. All rights reserved.</div>
                </div><!--/footer-->
        </div><!--/footer-wrapper-->
</div><!--/body-->
<script type="text/javascript" src="the-c-is-efficient-language-fallacy_files/addthis_widget.js"></script><div id="_atssh" style="visibility: hidden; height: 1px; width: 1px; position: absolute; z-index: 100000;"><iframe src="the-c-is-efficient-language-fallacy_files/sh142.html" style="height: 1px; width: 1px; position: absolute; z-index: 100000; border: 0px none; left: 0px; top: 0px;" title="AddThis utility frame" id="_atssh985"></iframe></div><script src="the-c-is-efficient-language-fallacy_files/core109.js" type="text/javascript"></script>
<script type="text/javascript" src="the-c-is-efficient-language-fallacy_files/jquery_002.js"></script>
<script type="text/javascript" src="the-c-is-efficient-language-fallacy_files/galleria.js"></script>
  <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-163469-3']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

<!-- Begin comScore Tag -->
<script>
  var _comscore = _comscore || [];
  _comscore.push({ c1: "2", c2: "3005368" });
  (function() {
    var s = document.createElement("script"), el = document.getElementsByTagName("script")[0]; s.async = true;
    s.src = (document.location.protocol == "https:" ? "https://sb" : "http://b") + ".scorecardresearch.com/beacon.js";
    el.parentNode.insertBefore(s, el);
  })();
</script>
<noscript>
  <img src="http://b.scorecardresearch.com/p?c1=2&c2=3005368&cv=2.0&cj=1" />
</noscript>
<!-- End comScore Tag -->


<div class=" fb_reset" id="fb-root"><script async="" src="the-c-is-efficient-language-fallacy_files/all.js"></script><div style="position: absolute; top: -10000px; height: 0px; width: 0px;"><div><iframe src="the-c-is-efficient-language-fallacy_files/ping.html" style="display: none;" allowtransparency="true" name="f1cd544998749be" scrolling="no" frameborder="0"></iframe></div></div><div style="position: absolute; top: -10000px; height: 0px; width: 0px;"><div><iframe src="the-c-is-efficient-language-fallacy_files/xd_arbiter.html" style="border: medium none;" tab-index="-1" title="Facebook Cross Domain Communication Frame" aria-hidden="true" id="fb_xdm_frame_http" allowtransparency="true" name="fb_xdm_frame_http" scrolling="no" frameborder="0"></iframe><iframe src="the-c-is-efficient-language-fallacy_files/xd_arbiter_002.html" style="border: medium none;" tab-index="-1" title="Facebook Cross Domain Communication Frame" aria-hidden="true" id="fb_xdm_frame_https" allowtransparency="true" name="fb_xdm_frame_https" scrolling="no" frameborder="0"></iframe></div></div></div><iframe style="width: 1px; height: 1px; position: absolute; top: -100px;" src="the-c-is-efficient-language-fallacy_files/postmessageRelay.html" id="oauth2relay621853512" name="oauth2relay621853512"></iframe></body></html>